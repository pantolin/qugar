<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QUGaR: qugar::ReparamMesh&lt; dim, range &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QUGaR<span id="projectnumber">&#160;0.0.7</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d99/classqugar_1_1ReparamMesh.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="../../d2/d2f/classqugar_1_1ReparamMesh-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">qugar::ReparamMesh&lt; dim, range &gt; Class Template Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Class for storing an implicit domain reparameterization using Lagrange cells.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d8/ddc/reparam__mesh_8hpp_source.html">reparam_mesh.hpp</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for qugar::ReparamMesh&lt; dim, range &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="../../db/d61/classqugar_1_1ReparamMesh__inherit__graph.svg" width="203" height="139"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a target="top" href="../../graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:add0e295d335a801f99465d5ec80e63ff" id="r_add0e295d335a801f99465d5ec80e63ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add0e295d335a801f99465d5ec80e63ff">ReparamMesh</a> (int order)</td></tr>
<tr class="memdesc:add0e295d335a801f99465d5ec80e63ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor.  <br /></td></tr>
<tr class="separator:add0e295d335a801f99465d5ec80e63ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a696ea984cde0de8da382815099745ee4" id="r_a696ea984cde0de8da382815099745ee4"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a696ea984cde0de8da382815099745ee4">~ReparamMesh</a> ()=default</td></tr>
<tr class="memdesc:a696ea984cde0de8da382815099745ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default virtual destructor.  <br /></td></tr>
<tr class="separator:a696ea984cde0de8da382815099745ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dd73789a167402be7359b5bff5825a4" id="r_a8dd73789a167402be7359b5bff5825a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dd73789a167402be7359b5bff5825a4">merge</a> (const <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">ReparamMesh</a>&lt; dim, range &gt; &amp;mesh)</td></tr>
<tr class="memdesc:a8dd73789a167402be7359b5bff5825a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges the given mesh into the current mesh.  <br /></td></tr>
<tr class="separator:a8dd73789a167402be7359b5bff5825a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7578cf3f64a200b938d338dff33081" id="r_a1d7578cf3f64a200b938d338dff33081"><td class="memTemplParams" colspan="2">template&lt;int aux_dim = dim&gt; <br />
requires (aux_dim == dim &amp;&amp; dim == range)</td></tr>
<tr class="memitem:a1d7578cf3f64a200b938d338dff33081"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1d7578cf3f64a200b938d338dff33081">add_full_cell</a> (const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;domain, bool wirebasket)</td></tr>
<tr class="memdesc:a1d7578cf3f64a200b938d338dff33081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a full cell to the mesh corresponding to the given domain.  <br /></td></tr>
<tr class="separator:a1d7578cf3f64a200b938d338dff33081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb9670d7d85475186ff156f0b0a6f23e" id="r_adb9670d7d85475186ff156f0b0a6f23e"><td class="memTemplParams" colspan="2">template&lt;int aux_dim = dim&gt; <br />
requires (aux_dim == dim &amp;&amp; dim == range)</td></tr>
<tr class="memitem:adb9670d7d85475186ff156f0b0a6f23e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb9670d7d85475186ff156f0b0a6f23e">add_full_cells</a> (const <a class="el" href="../../d1/d84/classqugar_1_1CartGridTP.html">CartGridTP</a>&lt; dim &gt; &amp;grid, const std::vector&lt; std::int64_t &gt; &amp;cell_ids, bool wirebasket)</td></tr>
<tr class="memdesc:adb9670d7d85475186ff156f0b0a6f23e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds full cells to the mesh corresponding to the grid.  <br /></td></tr>
<tr class="separator:adb9670d7d85475186ff156f0b0a6f23e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e4402baac2d766110df74349e35b2d" id="r_a91e4402baac2d766110df74349e35b2d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a91e4402baac2d766110df74349e35b2d">use_Chebyshev</a> () const</td></tr>
<tr class="memdesc:a91e4402baac2d766110df74349e35b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the Chebyshev nodes are used, or equally spaced nodes.  <br /></td></tr>
<tr class="separator:a91e4402baac2d766110df74349e35b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6ba97e2c53e46bbe8ebb037e5b290aa" id="r_aa6ba97e2c53e46bbe8ebb037e5b290aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa6ba97e2c53e46bbe8ebb037e5b290aa">insert_cell_point</a> (const <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; range &gt; &amp;point, int cell_id, int pt_id)</td></tr>
<tr class="memdesc:aa6ba97e2c53e46bbe8ebb037e5b290aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method sets the given point <code>point</code>, with index <code>pt_id</code>, to the cell designed by <code>cell_id</code>.  <br /></td></tr>
<tr class="separator:aa6ba97e2c53e46bbe8ebb037e5b290aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f12834c1f5d6bb4df40d2e8deb448a3" id="r_a8f12834c1f5d6bb4df40d2e8deb448a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8f12834c1f5d6bb4df40d2e8deb448a3">merge_coincident_points</a> (const <a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a> &amp;tol)</td></tr>
<tr class="memdesc:a8f12834c1f5d6bb4df40d2e8deb448a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merges coincident points in the reparameterization up to tolerance.  <br /></td></tr>
<tr class="separator:a8f12834c1f5d6bb4df40d2e8deb448a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa79e41dd53b34a8e42e4e6d5ba06f58" id="r_afa79e41dd53b34a8e42e4e6d5ba06f58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa79e41dd53b34a8e42e4e6d5ba06f58">scale_points</a> (const std::vector&lt; int &gt; &amp;point_ids, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;old_domain, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;new_domain)</td></tr>
<tr class="memdesc:afa79e41dd53b34a8e42e4e6d5ba06f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales points from an old domain to a new domain.  <br /></td></tr>
<tr class="separator:afa79e41dd53b34a8e42e4e6d5ba06f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf93fab8ea1adf1814cced461cacabb" id="r_abdf93fab8ea1adf1814cced461cacabb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdf93fab8ea1adf1814cced461cacabb">scale_points</a> (const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;old_domain, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;new_domain)</td></tr>
<tr class="memdesc:abdf93fab8ea1adf1814cced461cacabb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales points from an old domain to a new domain.  <br /></td></tr>
<tr class="separator:abdf93fab8ea1adf1814cced461cacabb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408fe6a3a10ca14c41fa44aec244d650" id="r_a408fe6a3a10ca14c41fa44aec244d650"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; range &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a408fe6a3a10ca14c41fa44aec244d650">get_points</a> () const</td></tr>
<tr class="memdesc:a408fe6a3a10ca14c41fa44aec244d650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the points the reparameterization points.  <br /></td></tr>
<tr class="separator:a408fe6a3a10ca14c41fa44aec244d650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd883ceded1997f17f9282287518d77c" id="r_acd883ceded1997f17f9282287518d77c"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd883ceded1997f17f9282287518d77c">get_connectivity</a> () const</td></tr>
<tr class="memdesc:acd883ceded1997f17f9282287518d77c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the reparameterization connectivity.  <br /></td></tr>
<tr class="separator:acd883ceded1997f17f9282287518d77c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfd2dc5c2f34496b2c35f993d53b43d" id="r_aedfd2dc5c2f34496b2c35f993d53b43d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::size_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedfd2dc5c2f34496b2c35f993d53b43d">get_wires_connectivity</a> () const</td></tr>
<tr class="memdesc:aedfd2dc5c2f34496b2c35f993d53b43d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the wirebasket reparameterization connectivity.  <br /></td></tr>
<tr class="separator:aedfd2dc5c2f34496b2c35f993d53b43d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ca48e376c50b7f3663542628737f21" id="r_ac6ca48e376c50b7f3663542628737f21"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6ca48e376c50b7f3663542628737f21">get_order</a> () const</td></tr>
<tr class="memdesc:ac6ca48e376c50b7f3663542628737f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the reparameterization's order.  <br /></td></tr>
<tr class="separator:ac6ca48e376c50b7f3663542628737f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbd0a72c29c3ca4cb86b84c3f92c9e5" id="r_a3fbd0a72c29c3ca4cb86b84c3f92c9e5"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fbd0a72c29c3ca4cb86b84c3f92c9e5">get_num_cells</a> () const</td></tr>
<tr class="memdesc:a3fbd0a72c29c3ca4cb86b84c3f92c9e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of reparameterization cells.  <br /></td></tr>
<tr class="separator:a3fbd0a72c29c3ca4cb86b84c3f92c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7977d7198e40c1e5c2f17f071c5664d9" id="r_a7977d7198e40c1e5c2f17f071c5664d9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7977d7198e40c1e5c2f17f071c5664d9">get_num_points</a> () const</td></tr>
<tr class="memdesc:a7977d7198e40c1e5c2f17f071c5664d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of points.  <br /></td></tr>
<tr class="separator:a7977d7198e40c1e5c2f17f071c5664d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a381911d2ecf2deee0c62c2fcf780e210" id="r_a381911d2ecf2deee0c62c2fcf780e210"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a381911d2ecf2deee0c62c2fcf780e210">get_num_points_per_cell</a> () const</td></tr>
<tr class="memdesc:a381911d2ecf2deee0c62c2fcf780e210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieves the number of points per cell, that depends on the reparameterization order.  <br /></td></tr>
<tr class="separator:a381911d2ecf2deee0c62c2fcf780e210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab29f9e5754eb7d5209750118d3a0ccd4" id="r_ab29f9e5754eb7d5209750118d3a0ccd4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab29f9e5754eb7d5209750118d3a0ccd4">write_VTK_file</a> (const std::string &amp;filename) const</td></tr>
<tr class="memdesc:ab29f9e5754eb7d5209750118d3a0ccd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the reparameterization data to a VTK file.  <br /></td></tr>
<tr class="separator:ab29f9e5754eb7d5209750118d3a0ccd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0270e9e57cbc114ace14a1f8ec74ee3f" id="r_a0270e9e57cbc114ace14a1f8ec74ee3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0270e9e57cbc114ace14a1f8ec74ee3f">permute_cell_directions</a> (std::size_t cell_id)</td></tr>
<tr class="memdesc:a0270e9e57cbc114ace14a1f8ec74ee3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the directions of the given cell.  <br /></td></tr>
<tr class="separator:a0270e9e57cbc114ace14a1f8ec74ee3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80404ba744433d0d041bb71c07bcafaa" id="r_a80404ba744433d0d041bb71c07bcafaa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80404ba744433d0d041bb71c07bcafaa">reserve_cells</a> (std::size_t n_new_cells)</td></tr>
<tr class="memdesc:a80404ba744433d0d041bb71c07bcafaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserves memory for a specified number of cells.  <br /></td></tr>
<tr class="separator:a80404ba744433d0d041bb71c07bcafaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e8a5849635bc8dbc97a57b91a3b3d8" id="r_aa5e8a5849635bc8dbc97a57b91a3b3d8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa5e8a5849635bc8dbc97a57b91a3b3d8">allocate_cells</a> (std::size_t n_new_cells)</td></tr>
<tr class="memdesc:aa5e8a5849635bc8dbc97a57b91a3b3d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for a specified number of cells.  <br /></td></tr>
<tr class="separator:aa5e8a5849635bc8dbc97a57b91a3b3d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a5ce7b3d2f9a31a093be1ee7ed7526180" id="r_a5ce7b3d2f9a31a093be1ee7ed7526180"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5ce7b3d2f9a31a093be1ee7ed7526180">use_Chebyshev</a> (int order)</td></tr>
<tr class="memdesc:a5ce7b3d2f9a31a093be1ee7ed7526180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determines whether the Chebyshev nodes are used, or equally spaced nodes.  <br /></td></tr>
<tr class="separator:a5ce7b3d2f9a31a093be1ee7ed7526180"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ae5298bb9776e6aa07972ac184d03e1fe" id="r_ae5298bb9776e6aa07972ac184d03e1fe"><td class="memItemLeft" align="right" valign="top">static const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5298bb9776e6aa07972ac184d03e1fe">chebyshev_order</a> = 7</td></tr>
<tr class="separator:ae5298bb9776e6aa07972ac184d03e1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a424c35311a8913d3310a61cffd0327c8" id="r_a424c35311a8913d3310a61cffd0327c8"><td class="memTemplParams" colspan="2">template&lt;int sub_dim&gt; </td></tr>
<tr class="memitem:a424c35311a8913d3310a61cffd0327c8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a424c35311a8913d3310a61cffd0327c8">check_edge_in_subdomain</a> (const std::vector&lt; std::size_t &gt; &amp;edge_points_ids, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;domain, const <a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a> &amp;tol) const</td></tr>
<tr class="memdesc:a424c35311a8913d3310a61cffd0327c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a reparameterization cell's edge belongs to a subentity of a <code>domain</code>.  <br /></td></tr>
<tr class="separator:a424c35311a8913d3310a61cffd0327c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57b7c295ab3c45944478ff38b5423c4a" id="r_a57b7c295ab3c45944478ff38b5423c4a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a57b7c295ab3c45944478ff38b5423c4a">check_subentity_degenerate</a> (const std::vector&lt; std::size_t &gt; &amp;points_ids, const <a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a> &amp;tol) const</td></tr>
<tr class="memdesc:a57b7c295ab3c45944478ff38b5423c4a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a reparameterization cell's sub-entity is degenerate (it has zero length).  <br /></td></tr>
<tr class="separator:a57b7c295ab3c45944478ff38b5423c4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accff477f5ad3ae173586c5e25e8e2c75" id="r_accff477f5ad3ae173586c5e25e8e2c75"><td class="memTemplParams" colspan="2">template&lt;int aux_dim = dim&gt; <br />
requires (aux_dim == dim &amp;&amp; 1 &lt; dim)</td></tr>
<tr class="memitem:accff477f5ad3ae173586c5e25e8e2c75"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#accff477f5ad3ae173586c5e25e8e2c75">get_edge_points</a> (int cell_id, int edge_id) const</td></tr>
<tr class="memdesc:accff477f5ad3ae173586c5e25e8e2c75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the ids of the points of an edge of a reparameterization cell.  <br /></td></tr>
<tr class="separator:accff477f5ad3ae173586c5e25e8e2c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8264f467d3a500aeb771c1702b0e4273" id="r_a8264f467d3a500aeb771c1702b0e4273"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8264f467d3a500aeb771c1702b0e4273">sort_edge_points</a> (std::span&lt; std::size_t &gt; edge_points_ids) const</td></tr>
<tr class="memdesc:a8264f467d3a500aeb771c1702b0e4273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the given edge points by their IDs.  <br /></td></tr>
<tr class="separator:a8264f467d3a500aeb771c1702b0e4273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe87a096696d57298802e28688ebe4a7" id="r_afe87a096696d57298802e28688ebe4a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe87a096696d57298802e28688ebe4a7">sort_wirebasket_edges</a> ()</td></tr>
<tr class="separator:afe87a096696d57298802e28688ebe4a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a474040fdbb663a9113e989dcd03a6dd8" id="r_a474040fdbb663a9113e989dcd03a6dd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a474040fdbb663a9113e989dcd03a6dd8">purge_duplicate_wirebasket_edges</a> ()</td></tr>
<tr class="separator:a474040fdbb663a9113e989dcd03a6dd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a92fac59daf85a2b688fbd71a568954fd" id="r_a92fac59daf85a2b688fbd71a568954fd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a92fac59daf85a2b688fbd71a568954fd">order_</a></td></tr>
<tr class="memdesc:a92fac59daf85a2b688fbd71a568954fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparameterization order (number of points per direction).  <br /></td></tr>
<tr class="separator:a92fac59daf85a2b688fbd71a568954fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebec1820e1bfcf88f58e6a82d5127784" id="r_aebec1820e1bfcf88f58e6a82d5127784"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; range &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebec1820e1bfcf88f58e6a82d5127784">points_</a></td></tr>
<tr class="memdesc:aebec1820e1bfcf88f58e6a82d5127784"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of points.  <br /></td></tr>
<tr class="separator:aebec1820e1bfcf88f58e6a82d5127784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af212d5010d53fefc81c32dcd1b6ac4" id="r_a6af212d5010d53fefc81c32dcd1b6ac4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6af212d5010d53fefc81c32dcd1b6ac4">connectivity_</a></td></tr>
<tr class="memdesc:a6af212d5010d53fefc81c32dcd1b6ac4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cells' connectivity.  <br /></td></tr>
<tr class="separator:a6af212d5010d53fefc81c32dcd1b6ac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c62f4559429a7f5ad8f69db443ab60" id="r_a49c62f4559429a7f5ad8f69db443ab60"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a49c62f4559429a7f5ad8f69db443ab60">wires_connectivity_</a></td></tr>
<tr class="memdesc:a49c62f4559429a7f5ad8f69db443ab60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cells wires' connectivity.  <br /></td></tr>
<tr class="separator:a49c62f4559429a7f5ad8f69db443ab60"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;int dim, int range&gt;<br />
class qugar::ReparamMesh&lt; dim, range &gt;</div><p>Class for storing an implicit domain reparameterization using Lagrange cells. </p>
<p>This reparameterization is non-conforming (it may contain hanging nodes), but is intended to be used for visualization purposes.</p>
<p>It stores the cells as a list of point and the connectivity. It also stores the connectivity for the wirebasket of the reparameterization.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Parametric dimension of the reparameterization. </td></tr>
    <tr><td class="paramname">range</td><td>Range (or physical dimension) of the reparameterization. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="add0e295d335a801f99465d5ec80e63ff" name="add0e295d335a801f99465d5ec80e63ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0e295d335a801f99465d5ec80e63ff">&#9670;&#160;</a></span>ReparamMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::ReparamMesh </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>Reparameterization order (number of points per direction). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a696ea984cde0de8da382815099745ee4" name="a696ea984cde0de8da382815099745ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a696ea984cde0de8da382815099745ee4">&#9670;&#160;</a></span>~ReparamMesh()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::~<a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">ReparamMesh</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default virtual destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1d7578cf3f64a200b938d338dff33081" name="a1d7578cf3f64a200b938d338dff33081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d7578cf3f64a200b938d338dff33081">&#9670;&#160;</a></span>add_full_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<div class="memtemplate">
template&lt;int aux_dim = dim&gt; <br />
requires (aux_dim == dim &amp;&amp; dim == range)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::add_full_cell </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wirebasket</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a full cell to the mesh corresponding to the given domain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">domain</td><td>The bounding box that defines the domain to which the full cell will be added. </td></tr>
    <tr><td class="paramname">wirebasket</td><td>Whether wirebasket for each cell should be added. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adb9670d7d85475186ff156f0b0a6f23e" name="adb9670d7d85475186ff156f0b0a6f23e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb9670d7d85475186ff156f0b0a6f23e">&#9670;&#160;</a></span>add_full_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<div class="memtemplate">
template&lt;int aux_dim = dim&gt; <br />
requires (aux_dim == dim &amp;&amp; dim == range)</div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::add_full_cells </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d1/d84/classqugar_1_1CartGridTP.html">CartGridTP</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>grid</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cell_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>wirebasket</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds full cells to the mesh corresponding to the grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">grid</td><td>Cartesian grid that define the cells to be added. </td></tr>
    <tr><td class="paramname">cell_ids</td><td>List of cells to add. </td></tr>
    <tr><td class="paramname">wirebasket</td><td>Whether wirebasket for each cell should be added.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>No coincidents points are merged. If needed, <code>merge_coincident_points</code> should be called after this method. </dd></dl>

</div>
</div>
<a id="aa5e8a5849635bc8dbc97a57b91a3b3d8" name="aa5e8a5849635bc8dbc97a57b91a3b3d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e8a5849635bc8dbc97a57b91a3b3d8">&#9670;&#160;</a></span>allocate_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::allocate_cells </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n_new_cells</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allocates memory for a specified number of cells. </p>
<p>For the points, it just reserves memory for the new points. Thus, new points should be pushed back.</p>
<p>However, for the cells connectivity, it resizes the array, ready to insert new indices at the corresponding positions.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_new_cells</td><td>The number of cells to allocate memory for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Id of the first allocated cell. </dd></dl>

</div>
</div>
<a id="a424c35311a8913d3310a61cffd0327c8" name="a424c35311a8913d3310a61cffd0327c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a424c35311a8913d3310a61cffd0327c8">&#9670;&#160;</a></span>check_edge_in_subdomain()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<div class="memtemplate">
template&lt;int sub_dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::check_edge_in_subdomain </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>edge_points_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a reparameterization cell's edge belongs to a subentity of a <code>domain</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">sub_dim</td><td>Parametric dimension of the subdomain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge_points_ids</td><td>Vector of point ids corresponding to the edge. </td></tr>
    <tr><td class="paramname">domain</td><td>Bounding box of the domain being considered. </td></tr>
    <tr><td class="paramname">tol</td><td><a class="el" href="../../db/d28/classqugar_1_1Tolerance.html" title="Class for tolerance related computations.">Tolerance</a> to be used if points belong to the wirebasket. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the edge sits on the subentity of dimension <code>sub_dim</code> of <code>domain</code>, false otherwise. </dd></dl>

</div>
</div>
<a id="a57b7c295ab3c45944478ff38b5423c4a" name="a57b7c295ab3c45944478ff38b5423c4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57b7c295ab3c45944478ff38b5423c4a">&#9670;&#160;</a></span>check_subentity_degenerate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::check_subentity_degenerate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>points_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a reparameterization cell's sub-entity is degenerate (it has zero length). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points_ids</td><td>Vector of point ids corresponding to the sub-entity. </td></tr>
    <tr><td class="paramname">tol</td><td><a class="el" href="../../db/d28/classqugar_1_1Tolerance.html" title="Class for tolerance related computations.">Tolerance</a> to decide if two points are coincident. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the subentity is degenerate, false otherwise. </dd></dl>

</div>
</div>
<a id="acd883ceded1997f17f9282287518d77c" name="acd883ceded1997f17f9282287518d77c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd883ceded1997f17f9282287518d77c">&#9670;&#160;</a></span>get_connectivity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::size_t &gt; &amp; <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::get_connectivity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the reparameterization connectivity. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the connectivity vector. </dd></dl>

</div>
</div>
<a id="accff477f5ad3ae173586c5e25e8e2c75" name="accff477f5ad3ae173586c5e25e8e2c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accff477f5ad3ae173586c5e25e8e2c75">&#9670;&#160;</a></span>get_edge_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<div class="memtemplate">
template&lt;int aux_dim = dim&gt; <br />
requires (aux_dim == dim &amp;&amp; 1 &lt; dim)</div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::size_t &gt; <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::get_edge_points </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cell_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>edge_id</em></span>&#160;) const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the ids of the points of an edge of a reparameterization cell. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_id</td><td>Id of the reparameterization cell to consider. </td></tr>
    <tr><td class="paramname">edge_id</td><td>Edge id of the reparameterization cell to consider. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of point ids of the edge. They are sorted such that the first point is smaller than the last one. If both are the same, the ids of the second points (from the begining and the end) are compared. </dd></dl>

</div>
</div>
<a id="a3fbd0a72c29c3ca4cb86b84c3f92c9e5" name="a3fbd0a72c29c3ca4cb86b84c3f92c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbd0a72c29c3ca4cb86b84c3f92c9e5">&#9670;&#160;</a></span>get_num_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::get_num_cells </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of reparameterization cells. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of reparameterization cells. </dd></dl>

</div>
</div>
<a id="a7977d7198e40c1e5c2f17f071c5664d9" name="a7977d7198e40c1e5c2f17f071c5664d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7977d7198e40c1e5c2f17f071c5664d9">&#9670;&#160;</a></span>get_num_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::get_num_points </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of points. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of points. </dd></dl>

</div>
</div>
<a id="a381911d2ecf2deee0c62c2fcf780e210" name="a381911d2ecf2deee0c62c2fcf780e210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a381911d2ecf2deee0c62c2fcf780e210">&#9670;&#160;</a></span>get_num_points_per_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::get_num_points_per_cell </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the number of points per cell, that depends on the reparameterization order. </p>
<dl class="section return"><dt>Returns</dt><dd>The number of points per cell as a std::size_t. </dd></dl>

</div>
</div>
<a id="ac6ca48e376c50b7f3663542628737f21" name="ac6ca48e376c50b7f3663542628737f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ca48e376c50b7f3663542628737f21">&#9670;&#160;</a></span>get_order()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::get_order </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the reparameterization's order. </p>
<dl class="section return"><dt>Returns</dt><dd>int Reparameterization order. </dd></dl>

</div>
</div>
<a id="a408fe6a3a10ca14c41fa44aec244d650" name="a408fe6a3a10ca14c41fa44aec244d650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408fe6a3a10ca14c41fa44aec244d650">&#9670;&#160;</a></span>get_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; range &gt; &gt; &amp; <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::get_points </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the points the reparameterization points. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to a vector containing points. </dd></dl>

</div>
</div>
<a id="aedfd2dc5c2f34496b2c35f993d53b43d" name="aedfd2dc5c2f34496b2c35f993d53b43d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfd2dc5c2f34496b2c35f993d53b43d">&#9670;&#160;</a></span>get_wires_connectivity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::size_t &gt; &amp; <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::get_wires_connectivity </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Retrieves the wirebasket reparameterization connectivity. </p>
<dl class="section return"><dt>Returns</dt><dd>A constant reference to the wirebasket connectivity vector. </dd></dl>

</div>
</div>
<a id="aa6ba97e2c53e46bbe8ebb037e5b290aa" name="aa6ba97e2c53e46bbe8ebb037e5b290aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6ba97e2c53e46bbe8ebb037e5b290aa">&#9670;&#160;</a></span>insert_cell_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::insert_cell_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>cell_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>pt_id</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method sets the given point <code>point</code>, with index <code>pt_id</code>, to the cell designed by <code>cell_id</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Point to be set. </td></tr>
    <tr><td class="paramname">cell_id</td><td>Flat index of the cell in which the point is set. </td></tr>
    <tr><td class="paramname">pt_id</td><td>Flat index of the reparameterization point referred to the cell. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8dd73789a167402be7359b5bff5825a4" name="a8dd73789a167402be7359b5bff5825a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd73789a167402be7359b5bff5825a4">&#9670;&#160;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">ReparamMesh</a>&lt; dim, range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>mesh</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges the given mesh into the current mesh. </p>
<p>This function takes another mesh as input and merges it with the current mesh. The points, connectivity, and wires connectivity are appended, shifting the indices by the number of points in the current mesh.</p>
<dl class="section note"><dt>Note</dt><dd>Coincident points are not merged and duplicated wires are not purged. </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Both meshes must have the same order.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mesh</td><td>The mesh to be merged with the current mesh. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8f12834c1f5d6bb4df40d2e8deb448a3" name="a8f12834c1f5d6bb4df40d2e8deb448a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f12834c1f5d6bb4df40d2e8deb448a3">&#9670;&#160;</a></span>merge_coincident_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::merge_coincident_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>tol</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merges coincident points in the reparameterization up to tolerance. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tol</td><td><a class="el" href="../../db/d28/classqugar_1_1Tolerance.html" title="Class for tolerance related computations.">Tolerance</a> to be used in the comparisons between points.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The connecitivity of cells (and wirebasket) is updated accordingly, and duplicated wirebasket edges are purged. </dd></dl>

</div>
</div>
<a id="a0270e9e57cbc114ace14a1f8ec74ee3f" name="a0270e9e57cbc114ace14a1f8ec74ee3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0270e9e57cbc114ace14a1f8ec74ee3f">&#9670;&#160;</a></span>permute_cell_directions()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::permute_cell_directions </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>cell_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the directions of the given cell. </p>
<p>If dimension is greater or equal than 2, the first two direction are permuted. Otherwise, if the dimension is 1, the first direction is reversed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell_id</td><td>The identifier of the cell whose directions are to be permuted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a474040fdbb663a9113e989dcd03a6dd8" name="a474040fdbb663a9113e989dcd03a6dd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a474040fdbb663a9113e989dcd03a6dd8">&#9670;&#160;</a></span>purge_duplicate_wirebasket_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::purge_duplicate_wirebasket_edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a80404ba744433d0d041bb71c07bcafaa" name="a80404ba744433d0d041bb71c07bcafaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80404ba744433d0d041bb71c07bcafaa">&#9670;&#160;</a></span>reserve_cells()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::reserve_cells </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>n_new_cells</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserves memory for a specified number of cells. </p>
<p>It only reserves memory, no resize performed, for poitns and cells connectivity. Not for wires.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_new_cells</td><td>The number of cells to allocate memory for. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abdf93fab8ea1adf1814cced461cacabb" name="abdf93fab8ea1adf1814cced461cacabb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf93fab8ea1adf1814cced461cacabb">&#9670;&#160;</a></span>scale_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::scale_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>old_domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_domain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales points from an old domain to a new domain. </p>
<p>This function takes two bounding boxes representing the old and new domains, and scales the points from the old to the new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_domain</td><td>The bounding box representing the old domain. </td></tr>
    <tr><td class="paramname">new_domain</td><td>The bounding box representing the new domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afa79e41dd53b34a8e42e4e6d5ba06f58" name="afa79e41dd53b34a8e42e4e6d5ba06f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa79e41dd53b34a8e42e4e6d5ba06f58">&#9670;&#160;</a></span>scale_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::scale_points </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point_ids</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>old_domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>new_domain</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales points from an old domain to a new domain. </p>
<p>This function takes two bounding boxes representing the old and new domains, and scales the points from the old to the new one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point_ids</td><td>List of points to scale. </td></tr>
    <tr><td class="paramname">old_domain</td><td>The bounding box representing the old domain. </td></tr>
    <tr><td class="paramname">new_domain</td><td>The bounding box representing the new domain. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8264f467d3a500aeb771c1702b0e4273" name="a8264f467d3a500aeb771c1702b0e4273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8264f467d3a500aeb771c1702b0e4273">&#9670;&#160;</a></span>sort_edge_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::sort_edge_points </td>
          <td>(</td>
          <td class="paramtype">std::span&lt; std::size_t &gt;</td>          <td class="paramname"><span class="paramname"><em>edge_points_ids</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the given edge points by their IDs. </p>
<p>They are sorted such that the first point is smaller than the last one. If both indices are equal, the ids of the second points (from the begining and the end) are compared.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">edge_points_ids</td><td>A span of edge point IDs to be sorted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe87a096696d57298802e28688ebe4a7" name="afe87a096696d57298802e28688ebe4a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe87a096696d57298802e28688ebe4a7">&#9670;&#160;</a></span>sort_wirebasket_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::sort_wirebasket_edges </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a91e4402baac2d766110df74349e35b2d" name="a91e4402baac2d766110df74349e35b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e4402baac2d766110df74349e35b2d">&#9670;&#160;</a></span>use_Chebyshev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::use_Chebyshev </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the Chebyshev nodes are used, or equally spaced nodes. </p>
<p>Chebyshev nodes should be used for high-order reparameterizations if the reparameterization order is greater or equal than <a class="el" href="#ae5298bb9776e6aa07972ac184d03e1fe">chebyshev_order</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>true if the Chebyshev method is used, false otherwise. </dd></dl>

</div>
</div>
<a id="a5ce7b3d2f9a31a093be1ee7ed7526180" name="a5ce7b3d2f9a31a093be1ee7ed7526180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ce7b3d2f9a31a093be1ee7ed7526180">&#9670;&#160;</a></span>use_Chebyshev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::use_Chebyshev </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determines whether the Chebyshev nodes are used, or equally spaced nodes. </p>
<p>Chebyshev nodes should be used for high-order reparameterizations if the reparameterization <code>order</code> is greater or equal than <a class="el" href="#ae5298bb9776e6aa07972ac184d03e1fe">chebyshev_order</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>order Reparameterization order. </dd>
<dd>
true if the Chebyshev method is used, false otherwise. </dd></dl>

</div>
</div>
<a id="ab29f9e5754eb7d5209750118d3a0ccd4" name="ab29f9e5754eb7d5209750118d3a0ccd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab29f9e5754eb7d5209750118d3a0ccd4">&#9670;&#160;</a></span>write_VTK_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::write_VTK_file </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;</td>          <td class="paramname"><span class="paramname"><em>filename</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the reparameterization data to a VTK file. </p>
<p>This function takes a reparameterization object and writes its data to a file in VTK format, which can be used for visualization in tools like ParaView.</p>
<p>If the repameterization contains a wirebasket mesh, the generated VTK files is composed of three files: a file with extension .vtmb that calls two .vtu files (one for the internal reparameterization), and one for the wirebasket.</p>
<p>If no wirebasket mesh is present, the generated VTK file is a single .vtu file for the internal reparameterization.</p>
<p>The reparameterizations of both the internal and wirebasket meshes is written as high-order Lagrange VTK cells.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>The name of the file to which the data will be written, without extension. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae5298bb9776e6aa07972ac184d03e1fe" name="ae5298bb9776e6aa07972ac184d03e1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5298bb9776e6aa07972ac184d03e1fe">&#9670;&#160;</a></span>chebyshev_order</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::chebyshev_order = 7</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Order for deciding if Chebyshev nodes are used for defining the Lagrange polynomials instead of equally spaced nodes. If the reparameterization order is greater than this value, Chebyshev nodes are used. </p>

</div>
</div>
<a id="a6af212d5010d53fefc81c32dcd1b6ac4" name="a6af212d5010d53fefc81c32dcd1b6ac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af212d5010d53fefc81c32dcd1b6ac4">&#9670;&#160;</a></span>connectivity_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::connectivity_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cells' connectivity. </p>

</div>
</div>
<a id="a92fac59daf85a2b688fbd71a568954fd" name="a92fac59daf85a2b688fbd71a568954fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92fac59daf85a2b688fbd71a568954fd">&#9670;&#160;</a></span>order_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::order_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reparameterization order (number of points per direction). </p>

</div>
</div>
<a id="aebec1820e1bfcf88f58e6a82d5127784" name="aebec1820e1bfcf88f58e6a82d5127784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebec1820e1bfcf88f58e6a82d5127784">&#9670;&#160;</a></span>points_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt;range&gt; &gt; <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::points_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector of points. </p>

</div>
</div>
<a id="a49c62f4559429a7f5ad8f69db443ab60" name="a49c62f4559429a7f5ad8f69db443ab60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49c62f4559429a7f5ad8f69db443ab60">&#9670;&#160;</a></span>wires_connectivity_</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::size_t&gt; <a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">qugar::ReparamMesh</a>&lt; dim, range &gt;::wires_connectivity_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cells wires' connectivity. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/__w/qugar/qugar/cpp/include/qugar/<a class="el" href="../../d8/ddc/reparam__mesh_8hpp_source.html">reparam_mesh.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d0/d6b/namespacequgar.html">qugar</a></li><li class="navelem"><a class="el" href="../../d8/d99/classqugar_1_1ReparamMesh.html">ReparamMesh</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
