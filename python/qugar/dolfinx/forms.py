# --------------------------------------------------------------------------
#
# Copyright (C) 2025-present by Pablo Antolin
#
# This file is part of the QUGaR library.
#
# SPDX-License-Identifier:    MIT
#
# This file is a modification of the original ``dolfinx/python/dolfinx/fem/forms.py`` file.
# See copyright below.
#
# Copyright (C) 2017-2024 Chris N. Richardson, Garth N. Wells, Michal Habera and JÃ¸rgen S. Dokken
#
# This file is part of DOLFINx (https://www.fenicsproject.org)
#
# SPDX-License-Identifier:    LGPL-3.0-or-later
#
# --------------------------------------------------------------------------


from __future__ import annotations

import collections.abc
import types
import typing
from itertools import chain

from qugar.utils import has_FEniCSx

if not has_FEniCSx:
    raise ValueError("FEniCSx installation not found is required.")

import numpy as np
import numpy.typing as npt
import ufl
import ufl.algorithms.analysis
from dolfinx import cpp as _cpp  # type: ignore
from dolfinx import default_scalar_type
from dolfinx.fem import IntegralType
from dolfinx.fem.forms import (
    Form,
    _ufl_to_dolfinx_domain,
    form_cpp_class,
    get_integration_domains,
)

from qugar.dolfinx.custom_coefficients import CustomCoeffsPacker
from qugar.dolfinx.integral_data import IntegralData
from qugar.dolfinx.jit import ffcx_jit
from qugar.mesh.unfitted_domain_abc import UnfittedDomainABC

if typing.TYPE_CHECKING:
    from dolfinx.mesh import Mesh


class CustomForm(Form):
    """Form for custom integrals.

    It derives from dolfinx.forms.Form just adding an extra
    functionality for computing the required custom coefficients at
    runtime (the method ``pack_coefficients``).

    """

    def __init__(
        self,
        form: typing.Union[
            _cpp.fem.Form_complex64,
            _cpp.fem.Form_complex128,
            _cpp.fem.Form_float32,
            _cpp.fem.Form_float64,
        ],
        domain: UnfittedDomainABC,
        itg_data: list[IntegralData],
        ufcx_form=None,
        code: str | None = None,
        module: typing.Optional[types.ModuleType] = None,
    ):
        """A custom finite element form.

        Note:
            CustomForms should normally be constructed using
            :func:`form_custom` and not using this class initialiser.
            This class is combined with different base classes that
            depend on the scalar type used in the Form.

        Args:
            form: Compiled form object.
            ufcx_form: UFCx form.
            code: Form C++ code.
            module: CFFI module.
        """
        super().__init__(form, ufcx_form, code, module)
        self._coeffs_packer = CustomCoeffsPacker(self, domain, itg_data)

    def pack_coefficients(
        self,
    ) -> dict[tuple[IntegralType, int], npt.NDArray]:
        """Function for generating the coefficients needed for computing
        custom integrals at runtime.

        Note:
            This function mimics the behaviour of
            ``dolfinx.cpp.fem.pack_coefficients``.

        Returns:
            dict[tuple[IntegralType, int], npt.NDArray]:
            Generated custom coefficients.
        """
        return self._coeffs_packer.pack_coefficients()

    def update_coefficients(
        self,
        old_coeffs: dict[tuple[IntegralType, int], npt.NDArray],
    ) -> dict[tuple[IntegralType, int], npt.NDArray]:
        """Function for updating the coefficients needed for computing
        custom integrals at runtime.

        It updated coefficients previously generated by just recomputing
        the part of the coefficients associated to the DOLFINx coefficients
        and keeping the part of the coefficients associated to the
        custom integrals.

        Returns:
            dict[tuple[IntegralType, int], npt.NDArray]:
            Generated custom coefficients.
        """
        return self._coeffs_packer.update_coefficients(old_coeffs)


def _modify_everywhere_exterior_facet_integrals(form):
    """Modify exterior facet integrals defined everywhere.

    Finds exterior facet integrals defined on the whole boundary
    (subdomain_id is "everywhere" or -1) and assigns them a unique
    integer ID greater than any existing exterior facet subdomain ID.
    It also adds metadata to mark these integrals.

    This is necessary because by default DOLFINx defines exterior
    facet integrals over the exterior facets only. However, in the
    case of unfitted meshes, exterior facets integral may need to be
    computed over non exterior facets.

    Args:
        form: The dolfinx form object.

    Returns:
        The modified dolfinx form object.
    """

    def _get_max_subdomain_id():
        subdomain_id = -1
        for integral in form.integrals():
            if integral.integral_type() == "exterior_facet":
                if isinstance(integral.subdomain_id(), int):
                    subdomain_id = max(subdomain_id, integral.subdomain_id())
        return subdomain_id + 1

    old_integrals = list(form.integrals())

    for i, integral in enumerate(form.integrals()):
        if integral.integral_type() == "exterior_facet":
            # Check if the integral is over the whole domain
            if integral.subdomain_id() in ("everywhere", -1):
                metadata = integral.metadata().copy()
                subdomain_id = integral.subdomain_id()
                subdomain_data = integral.subdomain_data()
                old_integrals[i] = integral.reconstruct(
                    subdomain_data, subdomain_id=subdomain_id, metadata=metadata
                )

                integral._subdomain_data = None
                integral._subdomain_id = _get_max_subdomain_id()
                integral._metadata.update({"ext_facet_everywhere": True})

    return form, tuple(old_integrals)


def form_custom(
    form: typing.Union[ufl.Form, typing.Iterable[ufl.Form]],
    dtype: npt.DTypeLike = default_scalar_type,
    form_compiler_options: typing.Optional[dict] = None,
    jit_options: typing.Optional[dict] = None,
    entity_maps: typing.Optional[dict[Mesh, npt.NDArray[np.int32]]] = None,
) -> CustomForm | None | list[CustomForm | None]:
    """Creates a CustomForm or a list of CustomForm to be integrated
    over custom domains.

    Note:
        This function is just a copy of
        ``dolfinx.fem.forms.form`` with some small
        modifications. Namely:

        - replacing ``dolfinx.jit.ffcx_jit`` with
          ``qugar.dolfinx.jit.ffcx_jit``.
        - creating a new form class ``CustomForm`` (that derives from
          ``dolfinx.forms.Form`` and adds a new functionalitiy for
          computing the required custom coefficients at runtime).

    Args:
        form: A UFL form or list(s) of UFL forms.
        domain (UnfittedDomainABC): The unfitted domain to integrate over.
        dtype: Scalar type to use for the compiled form.
        form_compiler_options: See :func:`ffcx_jit <dolfinx.jit.ffcx_jit>`
        jit_options: See :func:`ffcx_jit <dolfinx.jit.ffcx_jit>`.
        entity_maps: If any trial functions, test functions, or
            coefficients in the form are not defined over the same mesh
            as the integration domain, `entity_maps` must be supplied.
            For each key (a mesh, different to the integration domain
            mesh) a map should be provided relating the entities in the
            integration domain mesh to the entities in the key mesh e.g.
            for a key-value pair (msh, emap) in `entity_maps`, `emap[i]`
            is the entity in `msh` corresponding to entity `i` in the
            integration domain mesh.

    Returns:
        CustomForm | list[CustomForm]: Compiled finite element `CustomForm`.
        It can be a single form or a list of forms if the input
        `form` is a list of forms. If the provided form is empty,
        it returns `None`.

    Note:
        This function is responsible for the compilation of a UFL form
        (using FFCx) and attaching coefficients and domains specific
        data to the underlying C++ form. It dynamically create a
        :class:`Form` instance with an appropriate base class for the
        scalar type, e.g. :func:`_cpp.fem.Form_float64`.
    """

    if form_compiler_options is None:
        form_compiler_options = dict()

    form_compiler_options["scalar_type"] = dtype
    ftype = form_cpp_class(dtype)

    def _form(form) -> CustomForm:
        """Compile a single UFL form."""

        # In the case of exterior facets integrals everywhere in the
        # domain, the default exterior facets generated by DOLFINx
        # must be modified.
        form, old_integrals = _modify_everywhere_exterior_facet_integrals(form)

        # Extract subdomain data from UFL form
        sd = form.subdomain_data()
        (domain,) = list(sd.keys())  # Assuming single domain

        assert hasattr(domain, "unf_domain")
        unf_domain = domain.unf_domain
        assert isinstance(unf_domain, UnfittedDomainABC)

        # Check that subdomain data for each integral type is the same
        for data in sd.get(domain).values():
            assert all([d is data[0] for d in data])

        mesh = domain.ufl_cargo()
        if mesh is None:
            raise RuntimeError("Expecting to find a Mesh in the form.")
        itg_data, ufcx_form, module, code = ffcx_jit(
            mesh.comm,
            form,
            form_compiler_options=form_compiler_options,  # type: ignore
            jit_options=jit_options,
        )

        # For each argument in form extract its function space
        V = [arg.ufl_function_space()._cpp_object for arg in form.arguments()]

        # Prepare coefficients data. For every coefficient in form take
        # its C++ object.
        original_coeffs = form.coefficients()
        coeffs = [
            original_coeffs[ufcx_form.original_coefficient_positions[i]]._cpp_object
            for i in range(ufcx_form.num_coefficients)
        ]
        constants = [c._cpp_object for c in form.constants()]

        # Make map from integral_type to subdomain id
        subdomain_ids = {type: [] for type in sd.get(domain).keys()}
        everywhere_ext_facet_ids = []
        for integral in form.integrals():
            if integral.subdomain_data() is not None:
                # Subdomain ids can be strings, its or tuples with
                # strings and ints
                if integral.subdomain_id() != "everywhere":
                    try:
                        ids = [sid for sid in integral.subdomain_id() if sid != "everywhere"]
                    except TypeError:
                        # If not tuple, but single integer id
                        ids = [integral.subdomain_id()]
                else:
                    ids = []
                subdomain_ids[integral.integral_type()].append(ids)
            elif integral.integral_type() == "exterior_facet":
                metadata = integral.metadata()
                if "ext_facet_everywhere" in metadata and metadata["ext_facet_everywhere"]:
                    assert integral.subdomain_id() not in ("everywhere", -1)
                    everywhere_ext_facet_ids.append(integral.subdomain_id())

        # Chain and sort subdomain ids
        for itg_type, marker_ids in subdomain_ids.items():
            flattened_ids = list(chain.from_iterable(marker_ids))
            flattened_ids.sort()
            subdomain_ids[itg_type] = flattened_ids

        # Subdomain markers (possibly empty list for some integral
        # types)
        subdomains = {
            _ufl_to_dolfinx_domain[key]: get_integration_domains(
                _ufl_to_dolfinx_domain[key], subdomain_data[0], subdomain_ids[key]
            )
            for (key, subdomain_data) in sd.get(domain).items()
        }

        for subdomain_id in everywhere_ext_facet_ids:
            ext_facets = unf_domain.get_all_facets(ext_integral=True).as_array()
            subdomains[IntegralType.exterior_facet].append((subdomain_id, ext_facets))

        # Reverting modified exterior integrals
        form._integrals = old_integrals

        if entity_maps is None:
            _entity_maps = dict()
        else:
            _entity_maps = {msh._cpp_object: emap for (msh, emap) in entity_maps.items()}

        f = ftype(
            module.ffi.cast("uintptr_t", module.ffi.addressof(ufcx_form)),
            V,
            coeffs,
            constants,
            subdomains,
            _entity_maps,
            mesh,
        )
        return CustomForm(f, unf_domain, itg_data, ufcx_form, code, module)

    def _flatten_list(lst):
        new_lst = []
        for i in lst:
            if isinstance(i, list):
                new_lst.extend(_flatten_list(i))
        return new_lst

    def _create_form(form) -> CustomForm | None | list[CustomForm | None]:
        """Recursively convert ufl.Forms to dolfinx.fem.Form.

        Args:
            form: UFL form or list of UFL forms to extract DOLFINx forms
                from.

        Returns:
            A ``dolfinx.fem.Form`` or a list of ``dolfinx.fem.Form``.
        """
        if isinstance(form, ufl.Form):
            if form.empty():
                return None
            else:
                return _form(form)
        elif isinstance(form, collections.abc.Iterable):
            forms = _flatten_list(list(map(lambda sub_form: _create_form(sub_form), form)))
            return forms
        else:
            raise ValueError("Not implemented case.")

    return _create_form(form)
