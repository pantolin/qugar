<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>QUGaR: qugar::impl Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen-awesome-sidebar-only.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">QUGaR<span id="projectnumber">&#160;0.0.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d2/d5e/namespacequgar_1_1impl.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">qugar::impl Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d40/namespacequgar_1_1impl_1_1funcs.html">funcs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dba/namespacequgar_1_1impl_1_1tpms.html">tpms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dbc/classqugar_1_1impl_1_1AffineTransf.html">AffineTransf</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for representing affine transformations.  <a href="../../d0/dbc/classqugar_1_1impl_1_1AffineTransf.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dim-dimensional tensor-product Bezier polynomial function.  <a href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html">DomainFunc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Domain functions.  <a href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for storing an implicit domain reparameterization using Lagrange cells.  <a href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d87/classqugar_1_1impl_1_1MonomialsTP.html">MonomialsTP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">dim-dimensional tensor-product monomials function.  <a href="../../d2/d87/classqugar_1_1impl_1_1MonomialsTP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d05/classqugar_1_1impl_1_1PolynomialTP.html">PolynomialTP</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for tensor-product polynomial functions.  <a href="../../d2/d05/classqugar_1_1impl_1_1PolynomialTP.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d7b/classqugar_1_1impl_1_1RefSystem.html">RefSystem</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A class representing a reference system in a given dimension.  <a href="../../dc/d7b/classqugar_1_1impl_1_1RefSystem.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d46/structqugar_1_1impl_1_1RootsIntervals.html">RootsIntervals</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct for storing and managing computed roots and intervals of an implicit function.  <a href="../../d7/d46/structqugar_1_1impl_1_1RootsIntervals.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4eb0b10808db422fc21d669b326b8174" id="r_a4eb0b10808db422fc21d669b326b8174"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a4eb0b10808db422fc21d669b326b8174"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4eb0b10808db422fc21d669b326b8174">ScalarFunc</a> = <a class="el" href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html">DomainFunc</a>&lt;dim, 1&gt;</td></tr>
<tr class="memdesc:a4eb0b10808db422fc21d669b326b8174"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for scalar functions.  <br /></td></tr>
<tr class="separator:a4eb0b10808db422fc21d669b326b8174"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86700fba9e5deb1d550a7537ec8c8b02" id="r_a86700fba9e5deb1d550a7537ec8c8b02"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a86700fba9e5deb1d550a7537ec8c8b02"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a> = <a class="el" href="#a4eb0b10808db422fc21d669b326b8174">ScalarFunc</a>&lt;dim&gt;</td></tr>
<tr class="memdesc:a86700fba9e5deb1d550a7537ec8c8b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for implicit functions.  <br /></td></tr>
<tr class="separator:a86700fba9e5deb1d550a7537ec8c8b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a1958862994b81ad16e70737c86ca8f00" id="r_a1958862994b81ad16e70737c86ca8f00"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1958862994b81ad16e70737c86ca8f00">FuncSign</a> : std::int8_t { <a class="el" href="#a1958862994b81ad16e70737c86ca8f00a8c4efacb1f4c71f9e5e922c02481d364">negative</a>
, <a class="el" href="#a1958862994b81ad16e70737c86ca8f00aca03114f3fbc8358aebf5f7f84f09e93">positive</a>
, <a class="el" href="#a1958862994b81ad16e70737c86ca8f00afb9d1dd92e3f2e1293cd94de0442ed4c">undetermined</a>
 }</td></tr>
<tr class="separator:a1958862994b81ad16e70737c86ca8f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a59bbfd5bcf0c72a0d9a1b508bc15225f" id="r_a59bbfd5bcf0c72a0d9a1b508bc15225f"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; 3 &gt;, <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59bbfd5bcf0c72a0d9a1b508bc15225f">create_reference_system_around_axis</a> (<a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; 3 &gt; axis_z)</td></tr>
<tr class="separator:a59bbfd5bcf0c72a0d9a1b508bc15225f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad08cbe00b75bb8645e80f148bb8132d9" id="r_ad08cbe00b75bb8645e80f148bb8132d9"><td class="memTemplParams" colspan="2">template&lt;int dim, int range&gt; </td></tr>
<tr class="memitem:ad08cbe00b75bb8645e80f148bb8132d9"><td class="memTemplItemLeft" align="right" valign="top">static bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad08cbe00b75bb8645e80f148bb8132d9">is_bezier</a> (const <a class="el" href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html">DomainFunc</a>&lt; dim, range &gt; &amp;func)</td></tr>
<tr class="memdesc:ad08cbe00b75bb8645e80f148bb8132d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a given <a class="el" href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html" title="Domain functions.">DomainFunc</a> object is of type <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html" title="dim-dimensional tensor-product Bezier polynomial function.">BezierTP</a>.  <br /></td></tr>
<tr class="separator:ad08cbe00b75bb8645e80f148bb8132d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec77f630ac70eb8836ff4456359c91e" id="r_aaec77f630ac70eb8836ff4456359c91e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aaec77f630ac70eb8836ff4456359c91e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaec77f630ac70eb8836ff4456359c91e">evaluate_Bernstein_value</a> (const T &amp;point, const int order, std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:aaec77f630ac70eb8836ff4456359c91e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernstein polynomials of the given order.  <br /></td></tr>
<tr class="separator:aaec77f630ac70eb8836ff4456359c91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83494e71e1c1a31db74066adcc1d3711" id="r_a83494e71e1c1a31db74066adcc1d3711"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a83494e71e1c1a31db74066adcc1d3711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a83494e71e1c1a31db74066adcc1d3711">evaluate_Bernstein</a> (const T &amp;point, const int order, int der, std::vector&lt; T &gt; &amp;values)</td></tr>
<tr class="memdesc:a83494e71e1c1a31db74066adcc1d3711"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernstein polynomials of the given order (or its derivative).  <br /></td></tr>
<tr class="separator:a83494e71e1c1a31db74066adcc1d3711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ff94dce39f68431fd7975a241733202" id="r_a0ff94dce39f68431fd7975a241733202"><td class="memTemplParams" colspan="2">template&lt;int dim, int range&gt; </td></tr>
<tr class="memitem:a0ff94dce39f68431fd7975a241733202"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, range &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ff94dce39f68431fd7975a241733202">Bezier_product</a> (const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, range &gt; &amp;lhs, const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, range &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a0ff94dce39f68431fd7975a241733202"><td class="mdescLeft">&#160;</td><td class="mdescRight">Product of two Beziers.  <br /></td></tr>
<tr class="separator:a0ff94dce39f68431fd7975a241733202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e5b2dba084269f34d6fe32c22b516f1" id="r_a9e5b2dba084269f34d6fe32c22b516f1"><td class="memTemplParams" colspan="2">template&lt;int dim, int range, int dim2&gt; </td></tr>
<tr class="memitem:a9e5b2dba084269f34d6fe32c22b516f1"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, range &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9e5b2dba084269f34d6fe32c22b516f1">Bezier_composition</a> (const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim2, range &gt; &amp;lhs, const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, dim2 &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a9e5b2dba084269f34d6fe32c22b516f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the composition of two Beziers as rhs(lhs)  <br /></td></tr>
<tr class="separator:a9e5b2dba084269f34d6fe32c22b516f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a957bc2864404a1de1e2f3047337a3c38" id="r_a957bc2864404a1de1e2f3047337a3c38"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a957bc2864404a1de1e2f3047337a3c38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a957bc2864404a1de1e2f3047337a3c38">create_cell_quadrature</a> (const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;unf_domain, std::int64_t cell_id, int n_pts_dir, <a class="el" href="../../d8/dd5/structqugar_1_1CutCellsQuad.html">CutCellsQuad</a>&lt; dim &gt; &amp;quad)</td></tr>
<tr class="memdesc:a957bc2864404a1de1e2f3047337a3c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a quadrature for cut cells.  <br /></td></tr>
<tr class="separator:a957bc2864404a1de1e2f3047337a3c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade04127c99db26bfd44c12ee1a457bc" id="r_aade04127c99db26bfd44c12ee1a457bc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aade04127c99db26bfd44c12ee1a457bc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aade04127c99db26bfd44c12ee1a457bc">create_cell_unfitted_bound_quadrature</a> (const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;unf_domain, std::int64_t cell_id, int n_pts_dir, bool include_facet_unf_bdry, bool exclude_ext_bdry, <a class="el" href="../../d2/d41/structqugar_1_1CutUnfBoundsQuad.html">CutUnfBoundsQuad</a>&lt; dim &gt; &amp;quad)</td></tr>
<tr class="memdesc:aade04127c99db26bfd44c12ee1a457bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a quadrature for the unfitted boundary.  <br /></td></tr>
<tr class="separator:aade04127c99db26bfd44c12ee1a457bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360ae5183a48ffb55324aaf38f158ac9" id="r_a360ae5183a48ffb55324aaf38f158ac9"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a360ae5183a48ffb55324aaf38f158ac9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a360ae5183a48ffb55324aaf38f158ac9">create_facet_quadrature</a> (const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;unf_domain, std::int64_t cell_id, int local_facet_id, int n_pts_dir, bool remove_unf_bdry, bool remove_cut, <a class="el" href="../../df/d6d/structqugar_1_1CutIsoBoundsQuad.html">CutIsoBoundsQuad</a>&lt; dim - 1 &gt; &amp;quad)</td></tr>
<tr class="separator:a360ae5183a48ffb55324aaf38f158ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1eeaa3463436a48047fe6cc05e20ee2" id="r_ac1eeaa3463436a48047fe6cc05e20ee2"><td class="memTemplParams" colspan="2">template&lt;int dim, bool levelset&gt; </td></tr>
<tr class="memitem:ac1eeaa3463436a48047fe6cc05e20ee2"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; levelset ? dim - 1 :dim, dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac1eeaa3463436a48047fe6cc05e20ee2">create_reparameterization</a> (const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;unf_domain, int n_pts_dir, bool merge_points)</td></tr>
<tr class="separator:ac1eeaa3463436a48047fe6cc05e20ee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28df8e1e876cd4324551fb472df7e16a" id="r_a28df8e1e876cd4324551fb472df7e16a"><td class="memTemplParams" colspan="2">template&lt;int dim, bool levelset&gt; </td></tr>
<tr class="memitem:a28df8e1e876cd4324551fb472df7e16a"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; levelset ? dim - 1 :dim, dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a28df8e1e876cd4324551fb472df7e16a">create_reparameterization</a> (const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;unf_domain, const std::vector&lt; std::int64_t &gt; &amp;cells, int n_pts_dir, bool merge_points)</td></tr>
<tr class="separator:a28df8e1e876cd4324551fb472df7e16a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724a3556524d3dab193d182e3441479c" id="r_a724a3556524d3dab193d182e3441479c"><td class="memTemplParams" colspan="2">template&lt;int dim, bool S = false&gt; </td></tr>
<tr class="memitem:a724a3556524d3dab193d182e3441479c"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; S ? dim - 1 :dim, dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a724a3556524d3dab193d182e3441479c">reparam_Bezier</a> (const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, 1 &gt; &amp;bzr, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;domain, int order)</td></tr>
<tr class="memdesc:a724a3556524d3dab193d182e3441479c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparameterizes a Bezier implicit function in the unit hypercube domain.  <br /></td></tr>
<tr class="separator:a724a3556524d3dab193d182e3441479c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fc77331406a2659f2e6ba131f3f482" id="r_aa9fc77331406a2659f2e6ba131f3f482"><td class="memTemplParams" colspan="2">template&lt;int dim, bool S = false&gt; </td></tr>
<tr class="memitem:aa9fc77331406a2659f2e6ba131f3f482"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9fc77331406a2659f2e6ba131f3f482">reparam_Bezier</a> (const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, 1 &gt; &amp;bzr, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;domain, <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; S ? dim - 1 :dim, dim &gt; &amp;reparam)</td></tr>
<tr class="memdesc:aa9fc77331406a2659f2e6ba131f3f482"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparameterizes a Bezier implicit function in the unit hypercube domain.  <br /></td></tr>
<tr class="separator:aa9fc77331406a2659f2e6ba131f3f482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b9a9d91f7aaef06f08be59c5ce67cbe" id="r_a3b9a9d91f7aaef06f08be59c5ce67cbe"><td class="memTemplParams" colspan="2">template&lt;int dim, bool S = false&gt; </td></tr>
<tr class="memitem:a3b9a9d91f7aaef06f08be59c5ce67cbe"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; S ? dim - 1 :dim, dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b9a9d91f7aaef06f08be59c5ce67cbe">reparam_general</a> (const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;func, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;domain, int order)</td></tr>
<tr class="memdesc:a3b9a9d91f7aaef06f08be59c5ce67cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparameterizes the domain defined by a general implicit function.  <br /></td></tr>
<tr class="separator:a3b9a9d91f7aaef06f08be59c5ce67cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa89428c9856f8c3b1e6ea5efea4ed7" id="r_abaa89428c9856f8c3b1e6ea5efea4ed7"><td class="memTemplParams" colspan="2">template&lt;int dim, bool S = false&gt; </td></tr>
<tr class="memitem:abaa89428c9856f8c3b1e6ea5efea4ed7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abaa89428c9856f8c3b1e6ea5efea4ed7">reparam_general</a> (const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;func, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;domain, <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; S ? dim - 1 :dim, dim &gt; &amp;reparam)</td></tr>
<tr class="memdesc:abaa89428c9856f8c3b1e6ea5efea4ed7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparameterizes the domain defined by a general implicit function.  <br /></td></tr>
<tr class="separator:abaa89428c9856f8c3b1e6ea5efea4ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b150239e9ac1214830854a1875a56b4" id="r_a9b150239e9ac1214830854a1875a56b4"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a9b150239e9ac1214830854a1875a56b4"><td class="memTemplItemLeft" align="right" valign="top">std::shared_ptr&lt; <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; dim - 1, dim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b150239e9ac1214830854a1875a56b4">reparam_general_facet</a> (const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;func, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;domain, int facet_id, int order)</td></tr>
<tr class="memdesc:a9b150239e9ac1214830854a1875a56b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparameterizes a face of domain defined by an implicit function. It reparameterizes one of the 2*dim faces of the domain.  <br /></td></tr>
<tr class="separator:a9b150239e9ac1214830854a1875a56b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2526bba4f2d25931fb22fba16a53b008" id="r_a2526bba4f2d25931fb22fba16a53b008"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2526bba4f2d25931fb22fba16a53b008"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2526bba4f2d25931fb22fba16a53b008">reparam_general_facet</a> (const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;func, const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;domain, int facet_id, <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; dim - 1, dim &gt; &amp;reparam)</td></tr>
<tr class="memdesc:a2526bba4f2d25931fb22fba16a53b008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reparameterizes a face of domain defined by an implicit function. It reparameterizes one of the 2*dim faces of the domain.  <br /></td></tr>
<tr class="separator:a2526bba4f2d25931fb22fba16a53b008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd4d5befcbfbbd40224d42c72fd20882" id="r_acd4d5befcbfbbd40224d42c72fd20882"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:acd4d5befcbfbbd40224d42c72fd20882"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd4d5befcbfbbd40224d42c72fd20882">on_levelset</a> (const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;phi, const <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; dim &gt; &amp;point, <a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a> tol=<a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a>())</td></tr>
<tr class="memdesc:acd4d5befcbfbbd40224d42c72fd20882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a <code>point</code> belongs to the levelset of an implicit function <code>phi</code>.  <br /></td></tr>
<tr class="separator:acd4d5befcbfbbd40224d42c72fd20882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3885fffa69cb82a5463a32239aa77c18" id="r_a3885fffa69cb82a5463a32239aa77c18"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a3885fffa69cb82a5463a32239aa77c18"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3885fffa69cb82a5463a32239aa77c18">get_facet_constant_dir</a> (int local_facet_id)</td></tr>
<tr class="memdesc:a3885fffa69cb82a5463a32239aa77c18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the constant direction of the local facet.  <br /></td></tr>
<tr class="separator:a3885fffa69cb82a5463a32239aa77c18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e7ee00c7a8536c9ea56f6fc6320de7" id="r_a17e7ee00c7a8536c9ea56f6fc6320de7"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a17e7ee00c7a8536c9ea56f6fc6320de7"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a17e7ee00c7a8536c9ea56f6fc6320de7">get_facet_side</a> (int local_facet_id)</td></tr>
<tr class="memdesc:a17e7ee00c7a8536c9ea56f6fc6320de7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the side of the facet. Either 0 or 1.  <br /></td></tr>
<tr class="separator:a17e7ee00c7a8536c9ea56f6fc6320de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae031d88e7909c377635edf181a64f9ee" id="r_ae031d88e7909c377635edf181a64f9ee"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ae031d88e7909c377635edf181a64f9ee"><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae031d88e7909c377635edf181a64f9ee">get_local_facet_id</a> (int const_dir, int side)</td></tr>
<tr class="memdesc:ae031d88e7909c377635edf181a64f9ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the local facet ID for a given const direction and side.  <br /></td></tr>
<tr class="separator:ae031d88e7909c377635edf181a64f9ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071c3e24f3d4a9db67315a6a39e36a02" id="r_a071c3e24f3d4a9db67315a6a39e36a02"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a071c3e24f3d4a9db67315a6a39e36a02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6b/namespacequgar.html#a8f52d9219f5b006c008b0511ce6c1743">Vector</a>&lt; int, dim - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a071c3e24f3d4a9db67315a6a39e36a02">get_edge_constant_dirs</a> (int local_edge_id)</td></tr>
<tr class="memdesc:a071c3e24f3d4a9db67315a6a39e36a02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the constant directions of the local edge.  <br /></td></tr>
<tr class="separator:a071c3e24f3d4a9db67315a6a39e36a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c10001e993bd0d9ef1a4eb6161d4596" id="r_a3c10001e993bd0d9ef1a4eb6161d4596"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a3c10001e993bd0d9ef1a4eb6161d4596"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d6b/namespacequgar.html#a8f52d9219f5b006c008b0511ce6c1743">Vector</a>&lt; int, dim - 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3c10001e993bd0d9ef1a4eb6161d4596">get_edge_sides</a> (int local_edge_id)</td></tr>
<tr class="memdesc:a3c10001e993bd0d9ef1a4eb6161d4596"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sides of the edge. Either 0 or 1 along each constant direction.  <br /></td></tr>
<tr class="separator:a3c10001e993bd0d9ef1a4eb6161d4596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300b31d776b3499be317657ce45392bd" id="r_a300b31d776b3499be317657ce45392bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a300b31d776b3499be317657ce45392bd">evaluate_Lagrange_basis_1D</a> (<a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> point, int order, bool chebyshev, std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:a300b31d776b3499be317657ce45392bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Lagrange basis polynomials in 1D at a given point.  <br /></td></tr>
<tr class="separator:a300b31d776b3499be317657ce45392bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe05005c7ae0124bf1761c399f8caf3c" id="r_afe05005c7ae0124bf1761c399f8caf3c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe05005c7ae0124bf1761c399f8caf3c">evaluate_Lagrange_basis_der_1D</a> (<a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> point, int order, bool chebyshev, std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> &gt; &amp;values)</td></tr>
<tr class="memdesc:afe05005c7ae0124bf1761c399f8caf3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the first derivative of the Lagrange basis polynomial in 1D.  <br /></td></tr>
<tr class="separator:afe05005c7ae0124bf1761c399f8caf3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04ec6b518ce66c07ef954b144991c2c" id="r_ad04ec6b518ce66c07ef954b144991c2c"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad04ec6b518ce66c07ef954b144991c2c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad04ec6b518ce66c07ef954b144991c2c">evaluate_Lagrange_basis</a> (const <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; dim &gt; &amp;point, const <a class="el" href="../../d3/d39/classqugar_1_1TensorSizeTP.html">TensorSizeTP</a>&lt; dim &gt; &amp;order, bool chebyshev, std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> &gt; &amp;basis)</td></tr>
<tr class="memdesc:ad04ec6b518ce66c07ef954b144991c2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the tensor-product Lagrange basis functions at a given point.  <br /></td></tr>
<tr class="separator:ad04ec6b518ce66c07ef954b144991c2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2254fa568e6ab2e43f2cc7f84d272eef" id="r_a2254fa568e6ab2e43f2cc7f84d272eef"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a2254fa568e6ab2e43f2cc7f84d272eef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2254fa568e6ab2e43f2cc7f84d272eef">evaluate_Lagrange_derivative</a> (const <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; dim &gt; &amp;point, const <a class="el" href="../../d3/d39/classqugar_1_1TensorSizeTP.html">TensorSizeTP</a>&lt; dim &gt; &amp;order, bool chebyshev, <a class="el" href="../../d0/d6b/namespacequgar.html#a8f52d9219f5b006c008b0511ce6c1743">Vector</a>&lt; std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> &gt;, dim &gt; &amp;basis_ders)</td></tr>
<tr class="memdesc:a2254fa568e6ab2e43f2cc7f84d272eef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the derivative of the Lagrange basis functions at a given point, along all directions.  <br /></td></tr>
<tr class="separator:a2254fa568e6ab2e43f2cc7f84d272eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a86700fba9e5deb1d550a7537ec8c8b02" name="a86700fba9e5deb1d550a7537ec8c8b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86700fba9e5deb1d550a7537ec8c8b02">&#9670;&#160;</a></span>ImplicitFunc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">qugar::impl::ImplicitFunc</a> = <a class="el" href="#a4eb0b10808db422fc21d669b326b8174">ScalarFunc</a>&lt;dim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for implicit functions. </p>

</div>
</div>
<a id="a4eb0b10808db422fc21d669b326b8174" name="a4eb0b10808db422fc21d669b326b8174"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4eb0b10808db422fc21d669b326b8174">&#9670;&#160;</a></span>ScalarFunc</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="#a4eb0b10808db422fc21d669b326b8174">qugar::impl::ScalarFunc</a> = <a class="el" href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html">DomainFunc</a>&lt;dim, 1&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for scalar functions. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a1958862994b81ad16e70737c86ca8f00" name="a1958862994b81ad16e70737c86ca8f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1958862994b81ad16e70737c86ca8f00">&#9670;&#160;</a></span>FuncSign</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a1958862994b81ad16e70737c86ca8f00">qugar::impl::FuncSign</a> : std::int8_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1958862994b81ad16e70737c86ca8f00a8c4efacb1f4c71f9e5e922c02481d364" name="a1958862994b81ad16e70737c86ca8f00a8c4efacb1f4c71f9e5e922c02481d364"></a>negative&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1958862994b81ad16e70737c86ca8f00aca03114f3fbc8358aebf5f7f84f09e93" name="a1958862994b81ad16e70737c86ca8f00aca03114f3fbc8358aebf5f7f84f09e93"></a>positive&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1958862994b81ad16e70737c86ca8f00afb9d1dd92e3f2e1293cd94de0442ed4c" name="a1958862994b81ad16e70737c86ca8f00afb9d1dd92e3f2e1293cd94de0442ed4c"></a>undetermined&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9e5b2dba084269f34d6fe32c22b516f1" name="a9e5b2dba084269f34d6fe32c22b516f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e5b2dba084269f34d6fe32c22b516f1">&#9670;&#160;</a></span>Bezier_composition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range, int dim2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, range &gt; &gt; qugar::impl::Bezier_composition </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim2, range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, dim2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the composition of two Beziers as rhs(lhs) </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Dimension of the resultant Bezier. </td></tr>
    <tr><td class="paramname">range</td><td>Range of the resultant Bezier. </td></tr>
    <tr><td class="paramname">dim2</td><td>Common dimension between Beziers. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>Bezier to be composed. </td></tr>
    <tr><td class="paramname">rhs</td><td>Composing Bezier. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Resultant composition. </dd></dl>

</div>
</div>
<a id="a0ff94dce39f68431fd7975a241733202" name="a0ff94dce39f68431fd7975a241733202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ff94dce39f68431fd7975a241733202">&#9670;&#160;</a></span>Bezier_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, range &gt; &gt; qugar::impl::Bezier_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>lhs</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Product of two Beziers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lhs</td><td>First Bezier to multiply. </td></tr>
    <tr><td class="paramname">rhs</td><td>Second Bezier to multiply. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of Beziers. </dd></dl>

</div>
</div>
<a id="a957bc2864404a1de1e2f3047337a3c38" name="a957bc2864404a1de1e2f3047337a3c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a957bc2864404a1de1e2f3047337a3c38">&#9670;&#160;</a></span>create_cell_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::create_cell_quadrature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unf_domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>cell_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n_pts_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d8/dd5/structqugar_1_1CutCellsQuad.html">CutCellsQuad</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quad</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a quadrature for cut cells. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Dimension of the domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unf_domain</td><td>Unfitted domain. </td></tr>
    <tr><td class="paramname">cell_id</td><td>Cell for which the quadrature is created. </td></tr>
    <tr><td class="paramname">n_pts_dir</td><td>Number of points in each direction for generated custom quadratures. </td></tr>
    <tr><td class="paramname">quad</td><td><a class="el" href="../../d8/d30/classqugar_1_1Quadrature.html" title="Class for storing dim-dimensional quadratures (non-tensor product).">Quadrature</a> object to be filled with the generated quadrature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aade04127c99db26bfd44c12ee1a457bc" name="aade04127c99db26bfd44c12ee1a457bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade04127c99db26bfd44c12ee1a457bc">&#9670;&#160;</a></span>create_cell_unfitted_bound_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::create_cell_unfitted_bound_quadrature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unf_domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>cell_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n_pts_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>include_facet_unf_bdry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>exclude_ext_bdry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d41/structqugar_1_1CutUnfBoundsQuad.html">CutUnfBoundsQuad</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quad</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a quadrature for the unfitted boundary. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Dimension of the domain. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">unf_domain</td><td>Unitted domain. </td></tr>
    <tr><td class="paramname">cell_id</td><td>Cell for which the quadrature is created. </td></tr>
    <tr><td class="paramname">n_pts_dir</td><td>Number of points in each direction for generated custom quadratures. </td></tr>
    <tr><td class="paramname">include_facet_unf_bdry</td><td>If true, the quadrature includes the parts of the unfitted boundary that belong to the cells' facets. </td></tr>
    <tr><td class="paramname">exclude_ext_bdry</td><td>If the previous parameter is true, and this is one is false, the parts of the unfitted boundary that belong to the external facets are not included. </td></tr>
    <tr><td class="paramname">quad</td><td><a class="el" href="../../d8/d30/classqugar_1_1Quadrature.html" title="Class for storing dim-dimensional quadratures (non-tensor product).">Quadrature</a> object to be filled with the generated quadrature. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a360ae5183a48ffb55324aaf38f158ac9" name="a360ae5183a48ffb55324aaf38f158ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a360ae5183a48ffb55324aaf38f158ac9">&#9670;&#160;</a></span>create_facet_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::create_facet_quadrature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unf_domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>cell_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>local_facet_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n_pts_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_unf_bdry</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>remove_cut</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d6d/structqugar_1_1CutIsoBoundsQuad.html">CutIsoBoundsQuad</a>&lt; dim - 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>quad</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59bbfd5bcf0c72a0d9a1b508bc15225f" name="a59bbfd5bcf0c72a0d9a1b508bc15225f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bbfd5bcf0c72a0d9a1b508bc15225f">&#9670;&#160;</a></span>create_reference_system_around_axis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; 3 &gt;, <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; 3 &gt; &gt; qugar::impl::create_reference_system_around_axis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; 3 &gt;</td>          <td class="paramname"><span class="paramname"><em>axis_z</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28df8e1e876cd4324551fb472df7e16a" name="a28df8e1e876cd4324551fb472df7e16a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28df8e1e876cd4324551fb472df7e16a">&#9670;&#160;</a></span>create_reparameterization() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool levelset&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; levelset ? dim - 1 :dim, dim &gt; &gt; qugar::impl::create_reparameterization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unf_domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>cells</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n_pts_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>merge_points</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1eeaa3463436a48047fe6cc05e20ee2" name="ac1eeaa3463436a48047fe6cc05e20ee2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1eeaa3463436a48047fe6cc05e20ee2">&#9670;&#160;</a></span>create_reparameterization() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool levelset&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; const <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; levelset ? dim - 1 :dim, dim &gt; &gt; qugar::impl::create_reparameterization </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../da/de2/classqugar_1_1impl_1_1UnfittedImplDomain.html">UnfittedImplDomain</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>unf_domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>n_pts_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>merge_points</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83494e71e1c1a31db74066adcc1d3711" name="a83494e71e1c1a31db74066adcc1d3711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83494e71e1c1a31db74066adcc1d3711">&#9670;&#160;</a></span>evaluate_Bernstein()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::evaluate_Bernstein </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>der</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernstein polynomials of the given order (or its derivative). </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the input coordinate. </td></tr>
    <tr><td class="paramname">V</td><td>Type of the output vector of basis values. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Evaluation point. </td></tr>
    <tr><td class="paramname">order</td><td>Order of the polynomial. </td></tr>
    <tr><td class="paramname">der</td><td>Order of the derivative to be computed. If 0, the value itself is computed. </td></tr>
    <tr><td class="paramname">values</td><td>Computed basis values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaec77f630ac70eb8836ff4456359c91e" name="aaec77f630ac70eb8836ff4456359c91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaec77f630ac70eb8836ff4456359c91e">&#9670;&#160;</a></span>evaluate_Bernstein_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::evaluate_Bernstein_value </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernstein polynomials of the given order. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of the input coordinate. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>Evaluation point. </td></tr>
    <tr><td class="paramname">order</td><td>Order of the polynomial. </td></tr>
    <tr><td class="paramname">values</td><td>Computed basis values. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad04ec6b518ce66c07ef954b144991c2c" name="ad04ec6b518ce66c07ef954b144991c2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04ec6b518ce66c07ef954b144991c2c">&#9670;&#160;</a></span>evaluate_Lagrange_basis()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::evaluate_Lagrange_basis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d39/classqugar_1_1TensorSizeTP.html">TensorSizeTP</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>chebyshev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the tensor-product Lagrange basis functions at a given point. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point at which to evaluate the Lagrange basis functions. </td></tr>
    <tr><td class="paramname">order</td><td>The order (degree + 1) of the tensor product along each direction. </td></tr>
    <tr><td class="paramname">chebyshev</td><td>A boolean flag indicating whether to use Chebyshev nodes (true) of 2nd kind or standard equidistant nodes (false). </td></tr>
    <tr><td class="paramname">basis</td><td>A reference to a vector where the computed derivative values will be stored. This vector will be resized to the order of the Lagrange basis polynomials. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a300b31d776b3499be317657ce45392bd" name="a300b31d776b3499be317657ce45392bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300b31d776b3499be317657ce45392bd">&#9670;&#160;</a></span>evaluate_Lagrange_basis_1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::evaluate_Lagrange_basis_1D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>chebyshev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Lagrange basis polynomials in 1D at a given point. </p>
<p>This function computes the values of the Lagrange basis polynomials of a specified order at a given point. The basis can be evaluated using either Chebyshev nodes (of 2nd kind) or standard equidistant nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point at which to evaluate the Lagrange basis polynomials. </td></tr>
    <tr><td class="paramname">order</td><td>The order of the Lagrange basis polynomials (degree + 1). </td></tr>
    <tr><td class="paramname">chebyshev</td><td>A boolean flag indicating whether to use Chebyshev nodes (true) of 2nd kind or standard equidistant nodes (false). </td></tr>
    <tr><td class="paramname">values</td><td>A reference to a vector where the computed values of the Lagrange basis polynomials will be stored. This vector will be resized to the order of the Lagrange basis polynomials. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe05005c7ae0124bf1761c399f8caf3c" name="afe05005c7ae0124bf1761c399f8caf3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe05005c7ae0124bf1761c399f8caf3c">&#9670;&#160;</a></span>evaluate_Lagrange_basis_der_1D()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::evaluate_Lagrange_basis_der_1D </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a></td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>chebyshev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>values</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the first derivative of the Lagrange basis polynomial in 1D. </p>
<p>This function computes the values of the first derivative of the Lagrange basis polynomial at a given point for a specified order. The basis can be either Chebyshev (of 2nd kind) or equidistant nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point at which to evaluate the derivative. </td></tr>
    <tr><td class="paramname">order</td><td>The order of the Lagrange basis polynomial (degree + 1). </td></tr>
    <tr><td class="paramname">chebyshev</td><td>A boolean flag indicating whether to use Chebyshev nodes (true) of 2nd kind or standard equidistant nodes (false). </td></tr>
    <tr><td class="paramname">values</td><td>A reference to a vector where the computed derivative values will be stored. This vector will be resized to the order of the Lagrange basis polynomials. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2254fa568e6ab2e43f2cc7f84d272eef" name="a2254fa568e6ab2e43f2cc7f84d272eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2254fa568e6ab2e43f2cc7f84d272eef">&#9670;&#160;</a></span>evaluate_Lagrange_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::evaluate_Lagrange_derivative </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d3/d39/classqugar_1_1TensorSizeTP.html">TensorSizeTP</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>order</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>chebyshev</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d6b/namespacequgar.html#a8f52d9219f5b006c008b0511ce6c1743">Vector</a>&lt; std::vector&lt; <a class="el" href="../../d0/d6b/namespacequgar.html#a3b2859ebd1b264581cf555ba539903a3">real</a> &gt;, dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis_ders</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the derivative of the Lagrange basis functions at a given point, along all directions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">point</td><td>The point at which to evaluate the derivative of the Lagrange basis functions. </td></tr>
    <tr><td class="paramname">order</td><td>The order (degree + 1) of the tensor product along each direction. </td></tr>
    <tr><td class="paramname">chebyshev</td><td>A boolean flag indicating whether to use Chebyshev nodes (true) of 2nd kind or standard equidistant nodes (false). </td></tr>
    <tr><td class="paramname">basis_ders</td><td>A vector to store the computed derivatives of the Lagrange basis functions along all directions. The vectors along each direction will be resized to the order of the Lagrange basis polynomials. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a071c3e24f3d4a9db67315a6a39e36a02" name="a071c3e24f3d4a9db67315a6a39e36a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071c3e24f3d4a9db67315a6a39e36a02">&#9670;&#160;</a></span>get_edge_constant_dirs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6b/namespacequgar.html#a8f52d9219f5b006c008b0511ce6c1743">Vector</a>&lt; int, dim - 1 &gt; qugar::impl::get_edge_constant_dirs </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>local_edge_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the constant directions of the local edge. </p>
<p>The edges are assumed to follow a lexicographical numbering.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_edge_id</td><td>Id of the edge referred to a cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant directions in the range [0,dim[. </dd></dl>

</div>
</div>
<a id="a3c10001e993bd0d9ef1a4eb6161d4596" name="a3c10001e993bd0d9ef1a4eb6161d4596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c10001e993bd0d9ef1a4eb6161d4596">&#9670;&#160;</a></span>get_edge_sides()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d6b/namespacequgar.html#a8f52d9219f5b006c008b0511ce6c1743">Vector</a>&lt; int, dim - 1 &gt; qugar::impl::get_edge_sides </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>local_edge_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sides of the edge. Either 0 or 1 along each constant direction. </p>
<p>Along a constant direction, it returns if the local edge corresponds to the side of the cell's bounding box with minimum coordinate along the constant direction of the facet (0), or the maximum (1).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_edge_id</td><td>Id of the edge referred to a cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Sides of the edge. </dd></dl>

</div>
</div>
<a id="a3885fffa69cb82a5463a32239aa77c18" name="a3885fffa69cb82a5463a32239aa77c18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3885fffa69cb82a5463a32239aa77c18">&#9670;&#160;</a></span>get_facet_constant_dir()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int qugar::impl::get_facet_constant_dir </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>local_facet_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the constant direction of the local facet. </p>
<p>The constant direction is computed as the floor of division by 2 of <code>local_facet_id</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_facet_id</td><td>Id of the facet referred to a cell. It must be a value in the range [0, 2*dim[. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Constant direction in the range [0,dim[. </dd></dl>

</div>
</div>
<a id="a17e7ee00c7a8536c9ea56f6fc6320de7" name="a17e7ee00c7a8536c9ea56f6fc6320de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e7ee00c7a8536c9ea56f6fc6320de7">&#9670;&#160;</a></span>get_facet_side()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int qugar::impl::get_facet_side </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>local_facet_id</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the side of the facet. Either 0 or 1. </p>
<p>I.e., it returns if the local facet corresponds to the side of the cell's bounding box with minimum coordinate along the constant direction of the facet (0), or the maximum (1).</p>
<p>Side 0 correspond to even values of <code>local_facet_id</code>, and side 1 to odd values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">local_facet_id</td><td>Id of the facet referred to a cell. It must be a value in the range [0, 2*dim[. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Side of the facet. Either 0 or 1. </dd></dl>

</div>
</div>
<a id="ae031d88e7909c377635edf181a64f9ee" name="ae031d88e7909c377635edf181a64f9ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae031d88e7909c377635edf181a64f9ee">&#9670;&#160;</a></span>get_local_facet_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int qugar::impl::get_local_facet_id </td>
          <td>(</td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>const_dir</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>side</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the local facet ID for a given const direction and side. </p>
<p>This function returns the local facet ID based on the specified constant direction and side. It is used in the context of a multi-dimensional space where facets (or faces) of a geometric entity are identified.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension of the space. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">const_dir</td><td>The constant direction for which the local facet ID is to be determined. </td></tr>
    <tr><td class="paramname">side</td><td>The side (0 or 1) in the specified direction. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The local facet ID corresponding to the given direction and side. </dd></dl>

</div>
</div>
<a id="ad08cbe00b75bb8645e80f148bb8132d9" name="ad08cbe00b75bb8645e80f148bb8132d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad08cbe00b75bb8645e80f148bb8132d9">&#9670;&#160;</a></span>is_bezier()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool qugar::impl::is_bezier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html">DomainFunc</a>&lt; dim, range &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a given <a class="el" href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html" title="Domain functions.">DomainFunc</a> object is of type <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html" title="dim-dimensional tensor-product Bezier polynomial function.">BezierTP</a>. </p>
<p>This function uses dynamic_cast to determine if the provided <a class="el" href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html" title="Domain functions.">DomainFunc</a> object can be cast to a <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html" title="dim-dimensional tensor-product Bezier polynomial function.">BezierTP</a> object. If the cast is successful, the function returns true, indicating that the object is of type <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html" title="dim-dimensional tensor-product Bezier polynomial function.">BezierTP</a>. Otherwise, it returns false.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>The dimension of the <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html" title="dim-dimensional tensor-product Bezier polynomial function.">BezierTP</a> object. </td></tr>
    <tr><td class="paramname">range</td><td>The range of the <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html" title="dim-dimensional tensor-product Bezier polynomial function.">BezierTP</a> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>The <a class="el" href="../../dd/d80/classqugar_1_1impl_1_1DomainFunc.html" title="Domain functions.">DomainFunc</a> object to be checked. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the object is of type <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html" title="dim-dimensional tensor-product Bezier polynomial function.">BezierTP</a>, false otherwise. </dd></dl>

</div>
</div>
<a id="acd4d5befcbfbbd40224d42c72fd20882" name="acd4d5befcbfbbd40224d42c72fd20882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4d5befcbfbbd40224d42c72fd20882">&#9670;&#160;</a></span>on_levelset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool qugar::impl::on_levelset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>phi</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d0/d6b/namespacequgar.html#acedd2a0f9db919d923f32babff4d7b1f">Point</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>point</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a></td>          <td class="paramname"><span class="paramname"><em>tol</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="../../db/d28/classqugar_1_1Tolerance.html">Tolerance</a>()</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">nodiscard</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if a <code>point</code> belongs to the levelset of an implicit function <code>phi</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Dimension of the function and point. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">phi</td><td>Implicit function to be tested. </td></tr>
    <tr><td class="paramname">point</td><td>Point to be tested. </td></tr>
    <tr><td class="paramname">tol</td><td><a class="el" href="../../db/d28/classqugar_1_1Tolerance.html" title="Class for tolerance related computations.">Tolerance</a> to be used for checking if the value of <code>phi</code> is (close to) zero. If not provided, default tolerance is used. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Whether the point belong to the levelset of <code>phi</code>. </dd></dl>

</div>
</div>
<a id="aa9fc77331406a2659f2e6ba131f3f482" name="aa9fc77331406a2659f2e6ba131f3f482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fc77331406a2659f2e6ba131f3f482">&#9670;&#160;</a></span>reparam_Bezier() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool S = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::reparam_Bezier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bzr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; S ? dim - 1 :dim, dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reparam</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reparameterizes a Bezier implicit function in the unit hypercube domain. </p>
<dl class="section note"><dt>Note</dt><dd>The generated reparameterization has a wirebasket associated, but coincident were not merged.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Parametric dimension of the function. </td></tr>
    <tr><td class="paramname">S</td><td>Flag indicating if the reparameterization must be performed only for the levelset surface (true), i.e., the manifold where the Bezier function is equal to 0, or the volume (false), i.e., the subregion where the Bezier function is negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bzr</td><td>Bezier implicit function to reparameterize. </td></tr>
    <tr><td class="paramname">domain</td><td>Domain to which the implicit function refers to (even if Beziers are defined in the unit domain). </td></tr>
    <tr><td class="paramname">reparam</td><td>Reparameterization container to which new generated cells are appended to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a724a3556524d3dab193d182e3441479c" name="a724a3556524d3dab193d182e3441479c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a724a3556524d3dab193d182e3441479c">&#9670;&#160;</a></span>reparam_Bezier() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool S = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; S ? dim - 1 :dim, dim &gt; &gt; qugar::impl::reparam_Bezier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../de/dca/classqugar_1_1impl_1_1BezierTP.html">BezierTP</a>&lt; dim, 1 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>bzr</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reparameterizes a Bezier implicit function in the unit hypercube domain. </p>
<dl class="section note"><dt>Note</dt><dd>The generated reparameterization has a wirebasket associated, but coincident were not merged.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Parametric dimension of the function. </td></tr>
    <tr><td class="paramname">S</td><td>Flag indicating if the reparameterization must be performed only for the levelset surface (true), i.e., the manifold where the Bezier function is equal to 0, or the volume (false), i.e., the subregion where the Bezier function is negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bzr</td><td>Bezier implicit function to reparameterize. </td></tr>
    <tr><td class="paramname">domain</td><td>Domain to which the implicit function refers to (even if Beziers are defined in the unit domain). </td></tr>
    <tr><td class="paramname">order</td><td>Order of the reparameterization (number of points per direction in each reparameterization cell). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generated reparameterization. </dd></dl>

</div>
</div>
<a id="abaa89428c9856f8c3b1e6ea5efea4ed7" name="abaa89428c9856f8c3b1e6ea5efea4ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa89428c9856f8c3b1e6ea5efea4ed7">&#9670;&#160;</a></span>reparam_general() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool S = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::reparam_general </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; S ? dim - 1 :dim, dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reparam</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reparameterizes the domain defined by a general implicit function. </p>
<dl class="section note"><dt>Note</dt><dd>The generated reparameterization has a wirebasket associated, but coincident were not merged.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Parametric dimension of the function. </td></tr>
    <tr><td class="paramname">S</td><td>Flag indicating if the reparameterization must be performed only for the levelset surface (true), i.e., the manifold where the either of the two Bezier functions are equal to 0, or the subregion (false) between those surfaces, where both Bezier functions are negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to reparameterize. </td></tr>
    <tr><td class="paramname">domain</td><td>Domain to reparameterize. </td></tr>
    <tr><td class="paramname">reparam</td><td>Reparameterization container to which new generated cells are appended to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3b9a9d91f7aaef06f08be59c5ce67cbe" name="a3b9a9d91f7aaef06f08be59c5ce67cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b9a9d91f7aaef06f08be59c5ce67cbe">&#9670;&#160;</a></span>reparam_general() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, bool S = false&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; S ? dim - 1 :dim, dim &gt; &gt; qugar::impl::reparam_general </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reparameterizes the domain defined by a general implicit function. </p>
<dl class="section note"><dt>Note</dt><dd>The generated reparameterization has a wirebasket associated, but coincident were not merged.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Parametric dimension of the function. </td></tr>
    <tr><td class="paramname">S</td><td>Flag indicating if the reparameterization must be performed only for the levelset surface (true), i.e., the manifold where the either of the two Bezier functions are equal to 0, or the subregion (false) between those surfaces, where both Bezier functions are negative. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to reparameterize. </td></tr>
    <tr><td class="paramname">domain</td><td>Domain to reparameterize. </td></tr>
    <tr><td class="paramname">order</td><td>Order of the reparameterization (number of points per direction in each reparameterization cell). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generated reparameterization. </dd></dl>

</div>
</div>
<a id="a2526bba4f2d25931fb22fba16a53b008" name="a2526bba4f2d25931fb22fba16a53b008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2526bba4f2d25931fb22fba16a53b008">&#9670;&#160;</a></span>reparam_general_facet() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void qugar::impl::reparam_general_facet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; dim - 1, dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>reparam</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reparameterizes a face of domain defined by an implicit function. It reparameterizes one of the 2*dim faces of the domain. </p>
<dl class="section note"><dt>Note</dt><dd>The generated reparameterization has a wirebasket associated, but coincident were not merged.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Parametric dimension of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to reparameterize. </td></tr>
    <tr><td class="paramname">domain</td><td>Domain to reparameterize. </td></tr>
    <tr><td class="paramname">facet_id</td><td>Id of the face to reparameterize. It must be a value in the range [0, 2*dim[. </td></tr>
    <tr><td class="paramname">reparam</td><td>Reparameterization container to which new generated cells are appended to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9b150239e9ac1214830854a1875a56b4" name="a9b150239e9ac1214830854a1875a56b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b150239e9ac1214830854a1875a56b4">&#9670;&#160;</a></span>reparam_general_facet() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt; <a class="el" href="../../d1/d38/classqugar_1_1impl_1_1ImplReparamMesh.html">ImplReparamMesh</a>&lt; dim - 1, dim &gt; &gt; qugar::impl::reparam_general_facet </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a86700fba9e5deb1d550a7537ec8c8b02">ImplicitFunc</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>func</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d2/dfe/classqugar_1_1BoundBox.html">BoundBox</a>&lt; dim &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>domain</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>facet_id</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int</td>          <td class="paramname"><span class="paramname"><em>order</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reparameterizes a face of domain defined by an implicit function. It reparameterizes one of the 2*dim faces of the domain. </p>
<dl class="section note"><dt>Note</dt><dd>The generated reparameterization has a wirebasket associated, but coincident were not merged.</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">dim</td><td>Parametric dimension of the function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">func</td><td>Function to reparameterize. </td></tr>
    <tr><td class="paramname">domain</td><td>Domain to reparameterize. </td></tr>
    <tr><td class="paramname">facet_id</td><td>Id of the face to reparameterize. It must be a value in the range [0, 2*dim[. </td></tr>
    <tr><td class="paramname">order</td><td>Order of the reparameterization (number of points per direction in each reparameterization cell). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Generated reparameterization. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d0/d6b/namespacequgar.html">qugar</a></li><li class="navelem"><a class="el" href="../../d2/d5e/namespacequgar_1_1impl.html">impl</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
