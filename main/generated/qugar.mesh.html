

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>qugar.mesh &mdash; QUGaR 0.0.7 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=fa44fd50" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/general.css?v=c0a7eb24" />
      <link rel="stylesheet" type="text/css" href="../_static/dark_mode_css/dark.css?v=70edf1c7" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=bbaf98b3"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../_static/dark_mode_js/default_dark.js?v=fd565c74"></script>
      <script src="../_static/dark_mode_js/theme_switcher.js?v=358d3910"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="qugar.impl" href="qugar.impl.html" />
    <link rel="prev" title="qugar" href="qugar.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            QUGaR
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../demos.html">Demos</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../api.html">API reference</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../api_python.html">Python</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../api_python.html#public-user-interface">Public user interface</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="qugar.html">qugar</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">qugar.mesh</a></li>
<li class="toctree-l4"><a class="reference internal" href="qugar.impl.html">qugar.impl</a></li>
<li class="toctree-l4"><a class="reference internal" href="qugar.quad.html">qugar.quad</a></li>
<li class="toctree-l4"><a class="reference internal" href="qugar.reparam.html">qugar.reparam</a></li>
<li class="toctree-l4"><a class="reference internal" href="qugar.plot.html">qugar.plot</a></li>
<li class="toctree-l4"><a class="reference internal" href="qugar.dolfinx.html">qugar.dolfinx</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../api_python.html#nanobind-c-interface">nanobind/C++interface</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../api_cpp.html">C++</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../developer.html">Developer resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../contributing.html">Contributing</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QUGaR</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../api.html">API reference</a></li>
          <li class="breadcrumb-item"><a href="../api_python.html">Python</a></li>
      <li class="breadcrumb-item active">qugar.mesh</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/generated/qugar.mesh.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="module-qugar.mesh">
<span id="qugar-mesh"></span><h1>qugar.mesh<a class="headerlink" href="#module-qugar.mesh" title="Link to this heading"></a></h1>
<p>Mesh module for QUGaR</p>
<p class="rubric">Functions</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.DOLFINx_to_lexicg_edges" title="qugar.mesh.DOLFINx_to_lexicg_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DOLFINx_to_lexicg_edges</span></code></a>(dim)</p></td>
<td><p>Creates the permutation array to map from DOLFINx to lexicographical edges ordering.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.DOLFINx_to_lexicg_faces" title="qugar.mesh.DOLFINx_to_lexicg_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DOLFINx_to_lexicg_faces</span></code></a>(dim)</p></td>
<td><p>Creates the permutation array to map from DOLFINx to lexicographical faces ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.DOLFINx_to_lexicg_nodes" title="qugar.mesh.DOLFINx_to_lexicg_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DOLFINx_to_lexicg_nodes</span></code></a>(dim, degree)</p></td>
<td><p>Creates the permutation array to map from DOLFINx to lexicographical nodes ordering.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.DOLFINx_to_VTK_nodes" title="qugar.mesh.DOLFINx_to_VTK_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DOLFINx_to_VTK_nodes</span></code></a>(dim, degree)</p></td>
<td><p>Creates the permutation array to map from DOLFINx to VTK nodes ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.VTK_to_DOLFINx_nodes" title="qugar.mesh.VTK_to_DOLFINx_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VTK_to_DOLFINx_nodes</span></code></a>(dim, degree)</p></td>
<td><p>Creates the permutation array to map from VTK to DOLFINx nodes ordering.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.VTK_to_lexicg_nodes" title="qugar.mesh.VTK_to_lexicg_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VTK_to_lexicg_nodes</span></code></a>(dim, degree)</p></td>
<td><p>Creates the permutation array to map from VTK to lexicographical nodes ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.VTK_to_lexicg_faces" title="qugar.mesh.VTK_to_lexicg_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">VTK_to_lexicg_faces</span></code></a>(dim)</p></td>
<td><p>Creates the permutation array to map from VTK to lexicographical faces ordering.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.lexicg_to_DOLFINx_edges" title="qugar.mesh.lexicg_to_DOLFINx_edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lexicg_to_DOLFINx_edges</span></code></a>(dim)</p></td>
<td><p>Creates the permutation array to map from lexicographical to DOLFINx edges ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.lexicg_to_DOLFINx_faces" title="qugar.mesh.lexicg_to_DOLFINx_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lexicg_to_DOLFINx_faces</span></code></a>(dim)</p></td>
<td><p>Creates the permutation array to map from lexicographical to DOLFINx faces ordering.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.lexicg_to_VTK_faces" title="qugar.mesh.lexicg_to_VTK_faces"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lexicg_to_VTK_faces</span></code></a>(dim)</p></td>
<td><p>Creates the permutation array to map from lexicographical to VTK faces ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.lexicg_to_DOLFINx_nodes" title="qugar.mesh.lexicg_to_DOLFINx_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lexicg_to_DOLFINx_nodes</span></code></a>(dim, degree)</p></td>
<td><p>Creates the permutation array to map from lexicographical to DOLFINx nodes ordering.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.lexicg_to_VTK_nodes" title="qugar.mesh.lexicg_to_VTK_nodes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lexicg_to_VTK_nodes</span></code></a>(dim, degree)</p></td>
<td><p>Creates the permutation array to map from lexicographical to VTK nodes ordering.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.create_Cartesian_mesh" title="qugar.mesh.create_Cartesian_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_Cartesian_mesh</span></code></a>(comm, n_cells[, xmin, ...])</p></td>
<td><p>Creates a Cartesian mesh from a bounding box and the number of cells per direction.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.create_unfitted_impl_Cartesian_mesh" title="qugar.mesh.create_unfitted_impl_Cartesian_mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_unfitted_impl_Cartesian_mesh</span></code></a>(comm, ...)</p></td>
<td><p>Creates an uniftted Cartesian mesh generated with a bounding box and the number of cells per direction, and an implicit function describing the domain</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Classes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.Mesh" title="qugar.mesh.Mesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Mesh</span></code></a>(comm, nodes_coords, conn, cell_type[, ...])</p></td>
<td><p>Enriched mesh data structure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.UnfittedDomain" title="qugar.mesh.UnfittedDomain"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UnfittedDomain</span></code></a>(mesh, cpp_unf_domain_object)</p></td>
<td><p>Class for storing an unfitted domains and access its cut, full, and empty cells and facets, and create custom quadratures associated to those cells and facets.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.CartesianMesh" title="qugar.mesh.CartesianMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">CartesianMesh</span></code></a>(comm, cart_grid_tp_cpp, ...)</p></td>
<td><p>Cartesian mesh data structure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.TensorProductMesh" title="qugar.mesh.TensorProductMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorProductMesh</span></code></a>(comm, nodes_coords, n_cells)</p></td>
<td><p>Tensor-product mesh data structure.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#qugar.mesh.TensorProdIndex" title="qugar.mesh.TensorProdIndex"><code class="xref py py-obj docutils literal notranslate"><span class="pre">TensorProdIndex</span></code></a>()</p></td>
<td><p>Helper class for accessing indices in arbitrary dimensions tensor-product structures.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#qugar.mesh.UnfittedCartMesh" title="qugar.mesh.UnfittedCartMesh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">UnfittedCartMesh</span></code></a>(comm, cpp_unf_domain, ...)</p></td>
<td><p>Class for storing an unfitted Cartesian mesh domain and access its cut, full, and empty cells and facets.</p></td>
</tr>
</tbody>
</table>
<dl class="py class">
<dt class="sig sig-object py" id="qugar.mesh.CartesianMesh">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">CartesianMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm:</span> <span class="pre">~mpi4py.MPI.Comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cart_grid_tp_cpp:</span> <span class="pre">~qugar.cpp.CartGridTP_2D</span> <span class="pre">|</span> <span class="pre">~qugar.cpp.CartGridTP_3D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_cells:</span> <span class="pre">~numpy.ndarray[~typing.Any</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">~numpy.dtype[~numpy.int64]]</span> <span class="pre">|</span> <span class="pre">None</span> <span class="pre">=</span> <span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ghost_mode:</span> <span class="pre">~dolfinx.cpp.mesh.GhostMode</span> <span class="pre">=</span> <span class="pre">GhostMode.none</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype:</span> <span class="pre">type[~numpy.float32</span> <span class="pre">|</span> <span class="pre">~numpy.float64]</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qugar/mesh/tp_mesh.html#CartesianMesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.CartesianMesh" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#qugar.mesh.TensorProductMesh" title="qugar.mesh.tp_mesh.TensorProductMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">TensorProductMesh</span></code></a></p>
<p>Cartesian mesh data structure. This class is a helper class to
ease the construction and management of tensor-product (hypercube)
meshes aligned with the Cartesian axes.</p>
<p>It is only implemented for 2D and 3D.</p>
<p>I.e., tensor-product meshes (see <cite>TensorProductMesh</cite>) whose points
are distributed according to the Cartesian axes.</p>
<p>Constructor.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This constructor is not intended to be called directly,
but rather use the function <cite>create_Cartesian_mesh</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comm</strong> (<em>MPI.Comm</em>) – MPI communicator to be used for
distributing the mesh.</p></li>
<li><p><strong>cart_grid_tp_cpp</strong> (<a class="reference internal" href="qugar.cpp.html#qugar.cpp.CartGridTP_2D" title="qugar.cpp.CartGridTP_2D"><em>qugar.cpp.CartGridTP_2D</em></a><em> | </em><a class="reference internal" href="qugar.cpp.html#qugar.cpp.CartGridTP_3D" title="qugar.cpp.CartGridTP_3D"><em>qugar.cpp.CartGridTP_3D</em></a>) – C++ Cartesian grid object.</p></li>
<li><p><strong>degree</strong> (<em>int</em><em>, </em><em>optional</em>) – Degree of the mesh. Defaults to 1.
It must be greater than zero.</p></li>
<li><p><strong>active_cells</strong> (<em>Optional</em><em>[</em><em>npt.NDArray</em><em>[</em><em>np.int64</em><em>]</em><em>]</em>) – Array
storing the active cells of the Cartesian mesh
<cite>cart_grid_tp_cpp</cite>. If not set, all the cells are considered active.</p></li>
<li><p><strong>ghost_mode</strong> (<em>GhostMode</em><em>, </em><em>optional</em>) – Ghost mode used for mesh
partitioning. Defaults to <cite>none</cite>.</p></li>
<li><p><strong>dtype</strong> (<em>type</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em><em>, </em><em>optional</em>) – Type to
be used in the grid. Defaults to <cite>np.float64</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.CartesianMesh.cart_grid_tp_cpp_object">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cart_grid_tp_cpp_object</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="qugar.cpp.html#qugar.cpp.CartGridTP_2D" title="qugar.cpp.CartGridTP_2D"><span class="pre">CartGridTP_2D</span></a></em><a class="headerlink" href="#qugar.mesh.CartesianMesh.cart_grid_tp_cpp_object" title="Link to this definition"></a></dt>
<dd><p>Returns the stored (C++) Cartesian grid object.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Stored Cartesian
grid object.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="qugar.cpp.html#qugar.cpp.CartGridTP_2D" title="qugar.cpp.CartGridTP_2D">qugar.cpp.CartGridTP_2D</a> | <a class="reference internal" href="qugar.cpp.html#qugar.cpp.CartGridTP_2D" title="qugar.cpp.CartGridTP_2D">qugar.cpp.CartGridTP_2D</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.CartesianMesh.cell_breaks">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cell_breaks</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#qugar.mesh.CartesianMesh.cell_breaks" title="Link to this definition"></a></dt>
<dd><p>Gets the coordinates of the Cartesian grid cells along each direction</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Cell coordinates
along the parametric directions.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>list[npt.NDArray[np.float32 | np.float64]]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.CartesianMesh.get_cell_bbox">
<span class="sig-name descname"><span class="pre">get_cell_bbox</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dlf_local_cell_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int32</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_mesh.html#CartesianMesh.get_cell_bbox"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.CartesianMesh.get_cell_bbox" title="Link to this definition"></a></dt>
<dd><p>Computes the bounding box of a single cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dlf_local_cell_id</strong> (<em>np.int32</em>) – Local DOLFINx cell whose bounding box is created.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Computed bounding box</dt><dd><p>of the cell. It is a 2D with two rows and as many columns
as coordinates. Both rows represent the minimum and maximum
coordintes of the bounding box, respectively.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.float32 | np.float64]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.DOLFINx_to_VTK_nodes">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">DOLFINx_to_VTK_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#DOLFINx_to_VTK_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.DOLFINx_to_VTK_nodes" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from DOLFINx to VTK nodes
ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – Cell’s degree. It must be greater than 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from DOLFINx to VTK</dt><dd><p>such that <cite>a_dlf[i] = a_vtk[perm_array[i]]</cite> or
<cite>a_vtk[i] = perm_array[a_dlf[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The VTK numbering is referred to the Arbitrary-order Lagrange
Finite Elements as defined in
<a class="reference external" href="https://www.kitware.com//modeling-arbitrary-order-lagrange-finite-elements-in-the-visualization-toolkit">https://www.kitware.com//modeling-arbitrary-order-lagrange-finite-elements-in-the-visualization-toolkit</a>
These are the cells with cell ids 68 (1D), 70 (2D), or 72 (3D),
and not the linear ones (3, 9, 12, respec.) or quadratic (21,
28, 29, respec.).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.DOLFINx_to_lexicg_edges">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">DOLFINx_to_lexicg_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#DOLFINx_to_lexicg_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.DOLFINx_to_lexicg_edges" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from DOLFINx to
lexicographical edges ordering.</p>
<p>See <a class="reference external" href="https://github.com/FEniCS/basix/#supported-elements">https://github.com/FEniCS/basix/#supported-elements</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from DOLFINx to</dt><dd><p>lexicographical such that <cite>edges_lex[i] = edges_dlf[perm_array[i]]</cite> or
<cite>edges_dlf[i] = perm_array[edges_lex[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.DOLFINx_to_lexicg_faces">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">DOLFINx_to_lexicg_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#DOLFINx_to_lexicg_faces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.DOLFINx_to_lexicg_faces" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from DOLFINx to
lexicographical faces ordering.</p>
<p>See <a class="reference external" href="https://github.com/FEniCS/basix/#supported-elements">https://github.com/FEniCS/basix/#supported-elements</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from DOLFINx to</dt><dd><p>lexicographical such that <cite>faces_lex[i] = faces_dlf[perm_array[i]]</cite> or
<cite>faces_dlf[i] = perm_array[faces_lex[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.DOLFINx_to_lexicg_nodes">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">DOLFINx_to_lexicg_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#DOLFINx_to_lexicg_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.DOLFINx_to_lexicg_nodes" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from DOLFINx to
lexicographical nodes ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – Cell’s degree. It must be greater than 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from DOLFINx to</dt><dd><p>lexicographical, i.e., such that <cite>a_dlf[i] = a_lex[perm_array[i]]</cite> or
<cite>a_lex[i] = perm_array[a_dlf[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qugar.mesh.Mesh">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">Mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conn</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">CellType</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_cells</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ghost_mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GhostMode</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">GhostMode.none</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qugar/mesh/mesh.html#Mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.Mesh" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></p>
<p>Enriched mesh data structure.</p>
<p>This class derives from <cite>dolfinx.mesh.Mesh</cite>, easing the management of
of some mesh quantities.</p>
<p>For instance, it provides methods for easily quering the id of a cell in
the reference mesh or its corresponding counterpart referred to a
mesh created with DOLFINx.</p>
<p>The mesh can be partitioned among different processes using a MPI
communicator passed to the contructor. So, when queried about
indices of vertices, facets, cells, etc., the returns are referred
to the indices present in the current subdomain of the mesh.</p>
<p>Note that after the mesh creation, DOLFINx renumbers and partitions
the mesh, so, this numeration will be different. It is always
possible to retrieve the original numbering using the maps
<cite>self.get_original_node_ids</cite> or <cite>self.get_original_cell_ids</cite>.
Or, from the original numbering used to create the mesh to the local
DOLFINx numbering using <cite>self.get_DOLFINx_local_node_ids</cite> or
<cite>self.get_DOLFINx_local_cell_ids</cite>, or the global with
<cite>self.get_DOLFINx_global_node_ids</cite> or self.get_DOLFINx_global_cell_ids`,</p>
<p>Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comm</strong> (<em>MPI.Comm</em>) – MPI communicator to be used for
distributing the mesh.</p></li>
<li><p><strong>nodes_coords</strong> (<em>npt.NDArray</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em>) – Nodes
coordinates. The rows correspond to the different nodes
and the columns to the coordinates of each point.</p></li>
<li><p><strong>conn</strong> (<em>npt.NDArray</em><em>[</em><em>np.int64</em><em>]</em>) – Connectivity of the mesh.</p></li>
<li><p><strong>cell_type</strong> (<em>CellType</em>) – Type of the mesh cell.</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – Degree of the mesh.</p></li>
<li><p><strong>active_cells</strong> (<em>Optional</em><em>[</em><em>npt.NDArray</em><em>[</em><em>np.int64</em><em>]</em><em>]</em>) – Array of
active cells. If not set, all the cells are considered
active. The cells are referred to the original numbering
used to create the mesh.</p></li>
<li><p><strong>ghost_mode</strong> (<em>GhostMode</em><em>, </em><em>optional</em>) – Ghost mode used for mesh
partitioning. Defaults to <cite>none</cite>.</p></li>
<li><p><strong>merge_nodes</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, coincident nodes
will be merged together into a single one. Otherwise,
duplicated nodes will not be merged. Defaults to
<cite>False</cite>.</p></li>
<li><p><strong>merge_tol</strong> (<em>Optional</em><em>[</em><em>type</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em><em>]</em>) – Absolute
tolerance to be used for seeking coincident nodes.
If not set, and if <cite>merge_nodes</cite> is set to <cite>True</cite>,
this tolerance will be automatically computed in the
function <cite>merge_coincident_points_in_mesh</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.degree">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">degree</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#qugar.mesh.Mesh.degree" title="Link to this definition"></a></dt>
<dd><p>Gets the mesh’ degree.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mesh’s degree.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.dtype">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#qugar.mesh.Mesh.dtype" title="Link to this definition"></a></dt>
<dd><p>Gets the type associated to the breaks.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Type associated to the
breaks.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.dtype[np.float32] | np.dtype[np.float64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.gdim">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gdim</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#qugar.mesh.Mesh.gdim" title="Link to this definition"></a></dt>
<dd><p>Gets the geometrical dimension of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mesh’s geometrical dimension.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.get_DOLFINx_global_cell_ids">
<span class="sig-name descname"><span class="pre">get_DOLFINx_global_cell_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orig_cell_ids</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/mesh.html#Mesh.get_DOLFINx_global_cell_ids"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.Mesh.get_DOLFINx_global_cell_ids" title="Link to this definition"></a></dt>
<dd><p>Transforms the given local <cite>orig_cell_ids</cite> into the corresponding global ids
of the underlying DOLFINx mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orig_cell_ids</strong> (<em>npt.NDArray</em><em>[</em><em>np.int64</em><em>]</em>) – Cell indices to be transformed.
They are the original indices used to create the mesh.</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>All the indices in <cite>orig_cell_ids</cite> must be contained in the
current subdomain.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Indices of the cells in the underlying DOLFINx mesh.
These indices correspond to the global indices belonging to the
current subdomain (process).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.get_DOLFINx_local_cell_ids">
<span class="sig-name descname"><span class="pre">get_DOLFINx_local_cell_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orig_cell_ids</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/mesh.html#Mesh.get_DOLFINx_local_cell_ids"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.Mesh.get_DOLFINx_local_cell_ids" title="Link to this definition"></a></dt>
<dd><p>Transforms the given <cite>orig_cell_ids</cite> from the original numbering
into the corresponding local ids of the underlying DOLFINx mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orig_cell_ids</strong> (<em>npt.NDArray</em><em>[</em><em>np.int64</em><em>]</em>) – Cell indices to be transformed.
They are the original indices used to create the mesh.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Indices of the cells in
the underlying DOLFINx mesh. These indices correspond to the
local numbering associated to the current subdomain
(process). Note that some indices may be set to -1 in the
case the associated input original indices are not contained
in the subdomain. The length of the output
array is the same as the input.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.get_DOLFINx_local_node_ids">
<span class="sig-name descname"><span class="pre">get_DOLFINx_local_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orig_node_ids</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/mesh.html#Mesh.get_DOLFINx_local_node_ids"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.Mesh.get_DOLFINx_local_node_ids" title="Link to this definition"></a></dt>
<dd><p>Transforms the given <cite>orig_node_ids</cite> from the original
numbering into the corresponding local ids of the underlying
DOLFINx mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>orig_node_ids</strong> (<em>npt.NDArray</em><em>[</em><em>np.int64</em><em>]</em>) – Node indices to be transformed.
They are referred to the original numbering used to create the mesh.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Indices of the nodes in
the underlying DOLFINx mesh. These indices correspond to the
local numbering associated to the current subdomain
(process). Note that some indices may be set to -1 in the
case the input indices are original and some of them
are not contained in the subdomain. The length of the output
array is the same as the input.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.get_DOLFINx_local_to_global_cell_ids">
<span class="sig-name descname"><span class="pre">get_DOLFINx_local_to_global_cell_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dlf_local_cell_ids</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/mesh.html#Mesh.get_DOLFINx_local_to_global_cell_ids"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.Mesh.get_DOLFINx_local_to_global_cell_ids" title="Link to this definition"></a></dt>
<dd><p>Transforms the given local <cite>dlf_local_cell_ids</cite> (DOLFINx) local
cell ids into the corresponding global ones associated to the current process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dlf_local_cell_ids</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – DOLFINx local cell indices
to be transformed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Global indices of the DOLFINx cells.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.get_all_original_cell_ids">
<span class="sig-name descname"><span class="pre">get_all_original_cell_ids</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/mesh.html#Mesh.get_all_original_cell_ids"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.Mesh.get_all_original_cell_ids" title="Link to this definition"></a></dt>
<dd><p>Retrieves the ids of all the cells from the mesh using the original numbering.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>An array containing the original cell IDs.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>npt.nDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.get_cell_facets">
<span class="sig-name descname"><span class="pre">get_cell_facets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dlf_local_cell_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int32</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/mesh.html#Mesh.get_cell_facets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.Mesh.get_cell_facets" title="Link to this definition"></a></dt>
<dd><p>Extracts the facet ids of the given cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dlf_local_cell_id</strong> (<em>np.int32</em>) – Id of the queried cell. It is a DOLFINx
(local) cell id.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array of DOLFINx cell facets.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.get_original_cell_ids">
<span class="sig-name descname"><span class="pre">get_original_cell_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dlf_local_cell_ids</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/mesh.html#Mesh.get_original_cell_ids"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.Mesh.get_original_cell_ids" title="Link to this definition"></a></dt>
<dd><p>Transforms given <cite>dlf_local_cell_ids</cite> into
the original numbering used to create the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dlf_local_cell_ids</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Cell indices to be transformed. They arelocal
indices referred to the underlying DOLFINx mesh.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Ids of the cells in the original
numbering. The length of the output array is the same as the input.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.get_original_node_ids">
<span class="sig-name descname"><span class="pre">get_original_node_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dlf_local_node_ids</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/mesh.html#Mesh.get_original_node_ids"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.Mesh.get_original_node_ids" title="Link to this definition"></a></dt>
<dd><p>Transforms given <cite>dlf_local_node_ids</cite> from the (local) DOLFINx
mesh numbering to original numbering used to create the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dlf_local_node_ids</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Node indices to be transformed. They are referred to the
underlying (local) DOLFINx mesh.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Ids of the nodes in the original
numbering.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.has_inactive_cells">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">has_inactive_cells</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#qugar.mesh.Mesh.has_inactive_cells" title="Link to this definition"></a></dt>
<dd><p>Checks if the mesh has inactive cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the mesh has inactive cells.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.has_merged_nodes">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">has_merged_nodes</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">bool</span></em><a class="headerlink" href="#qugar.mesh.Mesh.has_merged_nodes" title="Link to this definition"></a></dt>
<dd><p>Checks if the mesh has merged nodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Whether the mesh has merged nodes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>bool</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.merged_nodes_map">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">merged_nodes_map</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#qugar.mesh.Mesh.merged_nodes_map" title="Link to this definition"></a></dt>
<dd><p>from original
ids to unique ones.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Map from old to new nodes.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>npt.NDArray[np.int64]</p>
</dd>
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p>Gets the map of original merged nodes</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.num_global_cells">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_global_cells</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int64</span></em><a class="headerlink" href="#qugar.mesh.Mesh.num_global_cells" title="Link to this definition"></a></dt>
<dd><p>Gets the total (global) number of cells of the DOLFINx mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of global cells of the DOLFINx mesh.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.int64</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.num_local_cells">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_local_cells</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int64</span></em><a class="headerlink" href="#qugar.mesh.Mesh.num_local_cells" title="Link to this definition"></a></dt>
<dd><p>Gets the local number of cells (associated to the current
subdomain, i.e., MPI process).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of local cells.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.int64</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.original_active_cells">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">original_active_cells</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#qugar.mesh.Mesh.original_active_cells" title="Link to this definition"></a></dt>
<dd><p>Gets the original active cells of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Original active cells.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.Mesh.tdim">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">tdim</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int</span></em><a class="headerlink" href="#qugar.mesh.Mesh.tdim" title="Link to this definition"></a></dt>
<dd><p>Gets the topological dimension of the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mesh’s topological dimension (1, 2, or 3).</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">TensorProdIndex</span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Helper class for accessing indices in arbitrary dimensions
tensor-product structures.</p>
<p>The indices in the tensor product structure follow the
lexicographical order, I.e., the direction 0 iterates the fastest,
i.e., is the inner-most, and the direction dim-1 iterates the
slowest, i.e., the outer-most. Where dim is the number of
dimensions.</p>
<p>I.e., in 2D this would be</p>
<blockquote>
<div><p>^ y
|
8 — 9 —10 — 11
|     |     |     |
4 — 5 — 6 — 7
|     |     |     |
0 — 1 — 2 — 3 –&gt; x</p>
</div></blockquote>
<p>When requested for specific corner, face, or edge indices,
the local index of the corresponding entity (corner, face, edge)
can be specified in lexicographical ordering or following
DOLFINx ordering.
See <a class="reference external" href="https://github.com/FEniCS/basix/#supported-elements">https://github.com/FEniCS/basix/#supported-elements</a></p>
<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex.get_all_corners">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_all_corners</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex.get_all_corners"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex.get_all_corners" title="Link to this definition"></a></dt>
<dd><p>Extracts the indices of the 2^dim corners of the hypercube.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_inds</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Number of indices per
dimension.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array storing the sorted indices of
the corners.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex.get_all_edges">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_all_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex.get_all_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex.get_all_edges" title="Link to this definition"></a></dt>
<dd><p>Extracts the edge indices of the hypercube.</p>
<p>In 3D the edge indices are those that correspond to the
intersection of two faces. In 1D and 2D, they are the same
as the face indices.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This method is not implemented yet for 3D.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_inds</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Number of indices per
dimension.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array storing the sorted edge
indices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex.get_all_faces">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_all_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex.get_all_faces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex.get_all_faces" title="Link to this definition"></a></dt>
<dd><p>Extracts the face indices of the hypercube.</p>
<p>The face indices are those that are on the boundaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_inds</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Number of indices per
dimension.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array storing the sorted boundary
indices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex.get_all_internal">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_all_internal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex.get_all_internal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex.get_all_internal" title="Link to this definition"></a></dt>
<dd><p>Extracts the internal indices of the hypercube.</p>
<p>The internal indices are those that are not on the boundaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_inds</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Number of indices per
dimension.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array storing the sorted internal
indices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex.get_corner">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_corner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local_corner_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int32</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int64</span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex.get_corner"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex.get_corner" title="Link to this definition"></a></dt>
<dd><p>Get the index associated to the given corner.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The local ordering of corners in DOLFINx coincides
with the lexicographical ordering.
See <a class="reference external" href="https://github.com/FEniCS/basix/#supported-elements">https://github.com/FEniCS/basix/#supported-elements</a></p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_inds</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Number of indices per
dimension.</p></li>
<li><p><strong>local_corner_id</strong> (<em>int</em><em> | </em><em>np.int32</em>) – Corner whose index is
extracted. It must be a value in the range <cite>[0,2^dim[</cite>
following the lexicographical ordering.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Index of the corner.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.int64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex.get_edge">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lexicg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex.get_edge"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex.get_edge" title="Link to this definition"></a></dt>
<dd><p>Get the indices associated to the given edge.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_inds</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Number of indices per
dimension.</p></li>
<li><p><strong>edge_id</strong> (<em>int</em><em> | </em><em>np.int32</em>) – Local edge id whose indices are
extracted.</p></li>
<li><p><strong>lexicg</strong> – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the given <cite>edge_id</cite> is referred to
the lexicographical ordering, otherwise, to the DOLFINx
one.
See <a class="reference external" href="https://github.com/FEniCS/basix/#supported-elements">https://github.com/FEniCS/basix/#supported-elements</a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Indices associated to the edge.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex.get_face">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_face</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">face_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int32</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lexicg</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex.get_face"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex.get_face" title="Link to this definition"></a></dt>
<dd><p>Get the indices associated to the given face.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_inds</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Number of indices per
dimension.</p></li>
<li><p><strong>face_id</strong> (<em>int</em><em> | </em><em>np.int32</em>) – Face whose indices is extracted.
It must be a value in the range [0, 2 * dim[, where
<cite>dim</cite> is the dimension of the domain.</p></li>
<li><p><strong>lexicg</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, the given <cite>face_id</cite> is referred
to the lexicographical ordering, otherwise, to the
DOLFINx one.
See <a class="reference external" href="https://github.com/FEniCS/basix/#supported-elements">https://github.com/FEniCS/basix/#supported-elements</a></p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Indices associated to the face.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int64]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex.get_flat_index">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_flat_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tid</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int64</span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex.get_flat_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex.get_flat_index" title="Link to this definition"></a></dt>
<dd><p>Transform a given tensor index to a flat one considering
<cite>n_inds</cite> indices per direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_inds</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Number of indices per
dimension.</p></li>
<li><p><strong>tid</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Tensor indices to be
transformed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Computed flat index.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>np.int64</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProdIndex.get_tensor_index">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_tensor_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int64</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_index.html#TensorProdIndex.get_tensor_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProdIndex.get_tensor_index" title="Link to this definition"></a></dt>
<dd><p>Transform a given index to a tensor one considering
<cite>n_inds</cite> indices per direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_inds</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Number of indices per
dimension.</p></li>
<li><p><strong>id</strong> (<em>int</em><em> | </em><em>np.int32</em><em> | </em><em>np.int64</em>) – Flat index to be
transformed.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Computed tensor index.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qugar.mesh.TensorProductMesh">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">TensorProductMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nodes_coords</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_cells</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_cells</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ghost_mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GhostMode</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">GhostMode.none</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">merge_tol</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qugar/mesh/tp_mesh.html#TensorProductMesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProductMesh" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#qugar.mesh.Mesh" title="qugar.mesh.mesh.Mesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">Mesh</span></code></a></p>
<p>Tensor-product mesh data structure.</p>
<p>This class derives from <cite>dolfinx.mesh.Mesh</cite>, easing the management of
structured tensor-product meshes of intervals (1D), quadrangles (2D), or
hexahedra (3D). The geometric dimension can be arbitrarity according
to the DOLFINx capabilities.</p>
<p>The class provides methods for easily quering the id of a cell in
the reference mesh or its corresponding counterpart referred to a
mesh created with DOLFINx.</p>
<p>It also provides functionalities for extracting the facets of a
cell, and the facets that belong to the mesh’s boundary, among
others.</p>
<p>The mesh can be partitioned among different processes using a MPI
communicator passed to the contructor. So, when queried about
indices of vertices, facets, cells, etc., the returns are referred
to the indices present in the current subdomain of the mesh.</p>
<p>The created mesh follows the denoted as lexicographical convention
for numbering cells and nodes. This ordering is such that the
parametric direction 0 iterates the fastest, i.e., is the
inner-most, and the direction dim-1 iterates the slowest, i.e., the
outer-most. The nodes and cells numbering for a  2D case would be:</p>
<blockquote>
<div><p>8 — 9 —10 —11              . — . — . — .
|     |     |     |              |  3  |  4  |  5  |
4 — 5 — 6 — 7              . — . — . — .
|     |     |     |              |  0  |  1  |  2  |
0 — 1 — 2 — 3              . — . — . — .</p>
</div></blockquote>
<p>Note that after the mesh creation, DOLFINx renumbers and partitions
the mesh, so, this numeration will be different. It is always
possible to retrieve the original numbering using the maps
<cite>self.get_original_node_ids</cite> or <cite>self.get_original_cell_ids</cite>.
Or, from the lexicographical to the local DOLFINx numbering using
<cite>self.get_DOLFINx_local_node_ids</cite> or <cite>self.get_DOLFINx_local_cell_ids</cite>,
or the global with <cite>self.get_DOLFINx_global_node_ids</cite> or
<cite>self.get_DOLFINx_global_cell_ids</cite>,</p>
<p>Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comm</strong> (<em>MPI.Comm</em>) – MPI communicator to be used for
distributing the mesh.</p></li>
<li><p><strong>n_cells</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>] </em><em>| </em><em>list</em><em>[</em><em>np.int32</em><em>] </em><em>| </em><em>list</em><em>[</em><em>int</em><em>]</em>) – Number of cells per direction in the mesh.</p></li>
<li><p><strong>nodes_coords</strong> (<em>npt.NDArray</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em>) – Nodes
coordinates. The rows correspond to the different nodes
(following lexicographical ordering), and the columns to
the coordinates of each point.</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – Degree of the mesh.</p></li>
<li><p><strong>active_cells</strong> (<em>Optional</em><em>[</em><em>npt.NDArray</em><em>[</em><em>np.int64</em><em>]</em><em>]</em>) – Array
storing the active cells of the mesh. If not set, all
the cells are considered active. Defaults to <cite>None</cite>.</p></li>
<li><p><strong>ghost_mode</strong> (<em>GhostMode</em><em>, </em><em>optional</em>) – Ghost mode used for mesh
partitioning. Defaults to <cite>none</cite>.</p></li>
<li><p><strong>merge_nodes</strong> (<em>bool</em><em>, </em><em>optional</em>) – If <cite>True</cite>, coincident nodes
will be merged together into a single one. Otherwise,
duplicated nodes will not be merged. Defaults to
<cite>False</cite>.</p></li>
<li><p><strong>merge_tol</strong> (<em>Optional</em><em>[</em><em>type</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em><em>]</em>) – Absolute
tolerance to be used for seeking coincident nodes.
If not set, and if <cite>merge_nodes</cite> is set to <cite>True</cite>,
this tolerance will be automatically computed in the
function <cite>merge_coincident_points_in_mesh</cite>.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProductMesh.create_facet_bdry_tags">
<span class="sig-name descname"><span class="pre">create_facet_bdry_tags</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">MeshTags</span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_mesh.html#TensorProductMesh.create_facet_bdry_tags"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProductMesh.create_facet_bdry_tags" title="Link to this definition"></a></dt>
<dd><p>Creates face facet tags for the tensor product mesh.</p>
<p>It creates the tags for the facets of the underlying DOLFINx mesh,
setting a different tag for each boundary face of the domain.</p>
<p>The created tags follow the lexicographical ordering of the
tensor-product mesh. I.e., umin:0, umax:1, vmin:2, vmax:3, …</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Generated tags.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>dolfinx.mesh.MeshTags</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProductMesh.get_cell_tensor_index">
<span class="sig-name descname"><span class="pre">get_cell_tensor_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dlf_local_cell_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int32</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_mesh.html#TensorProductMesh.get_cell_tensor_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProductMesh.get_cell_tensor_index" title="Link to this definition"></a></dt>
<dd><p>Computes the tensor index referred to the tensor-product mesh
of a given (local) DOLFINx cell index.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dlf_local_cell_id</strong> (<em>np.int32</em>) – Local DOLFINx cell index to be transformed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Cell tensor index</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProductMesh.get_face_DOLFINx_cells">
<span class="sig-name descname"><span class="pre">get_face_DOLFINx_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tp_face_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_mesh.html#TensorProductMesh.get_face_DOLFINx_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProductMesh.get_face_DOLFINx_cells" title="Link to this definition"></a></dt>
<dd><p>Extracts the (local) DOLFINx indices of the cells touching the given face
of the tensor-product mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>tp_face_id</strong> (<em>int</em>) – Id of the face whose cells are extracted.
This id follows the lexicographical ordering.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array storing the local cells indices
referred to the underlying DOLFINx mesh numbering for the
current subdomain (process).
This array is unique and sorted. Note that it may be empty
if the cells associated to the face do not belong to the
current subdomain.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.TensorProductMesh.get_face_facets">
<span class="sig-name descname"><span class="pre">get_face_facets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">face_id</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_mesh.html#TensorProductMesh.get_face_facets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.TensorProductMesh.get_face_facets" title="Link to this definition"></a></dt>
<dd><p>Extracts the facets indices of the given face of the tensor-product
mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>face_id</strong> (<em>int</em>) – Id of the face whose facets are extracted.
This id follows the lexicographical ordering.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Array storing the facets indices
referred to the underlying DOLFINx mesh numbering.
This array is unique and sorted. Note that it may be empty
if the facets associated to the face do not belong to the
current subdomain.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.TensorProductMesh.num_cells_dir">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_cells_dir</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#qugar.mesh.TensorProductMesh.num_cells_dir" title="Link to this definition"></a></dt>
<dd><p>Gets the number of cells per direction in the mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of cells per direction.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.TensorProductMesh.num_cells_tp">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_cells_tp</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">int64</span></em><a class="headerlink" href="#qugar.mesh.TensorProductMesh.num_cells_tp" title="Link to this definition"></a></dt>
<dd><p>Gets the total number of cells of the underlying tensor-product mesh.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of cells of the tensor-product mesh.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.int64</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.TensorProductMesh.num_pts_dir">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_pts_dir</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#qugar.mesh.TensorProductMesh.num_pts_dir" title="Link to this definition"></a></dt>
<dd><p>Gets the number of points per direction in the mesh
taking into account the number of cells per direction and
the mesh’s degree.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Number of points per direction.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedCartMesh">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">UnfittedCartMesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm:</span> <span class="pre">~mpi4py.MPI.Comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cpp_unf_domain:</span> <span class="pre">~qugar.cpp.UnfittedDomain_2D</span> <span class="pre">|</span> <span class="pre">~qugar.cpp.UnfittedDomain_3D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cpp_cart_grid_tp:</span> <span class="pre">~qugar.cpp.CartGridTP_2D</span> <span class="pre">|</span> <span class="pre">~qugar.cpp.CartGridTP_3D</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree:</span> <span class="pre">int</span> <span class="pre">=</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_empty_cells:</span> <span class="pre">bool</span> <span class="pre">=</span> <span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ghost_mode:</span> <span class="pre">~dolfinx.cpp.mesh.GhostMode</span> <span class="pre">=</span> <span class="pre">GhostMode.none</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype:</span> <span class="pre">type[~numpy.float32</span> <span class="pre">|</span> <span class="pre">~numpy.float64]</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_cart_mesh.html#UnfittedCartMesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedCartMesh" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#qugar.mesh.CartesianMesh" title="qugar.mesh.tp_mesh.CartesianMesh"><code class="xref py py-class docutils literal notranslate"><span class="pre">CartesianMesh</span></code></a>, <a class="reference internal" href="#qugar.mesh.UnfittedDomain" title="qugar.mesh.unfitted_domain.UnfittedDomain"><code class="xref py py-class docutils literal notranslate"><span class="pre">UnfittedDomain</span></code></a></p>
<p>Class for storing an unfitted Cartesian mesh domain
and access its cut, full, and empty cells and facets.</p>
<p>Constructor.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This constructor is not intended to be called directly,
but rather use the function <cite>create_Cartesian_mesh</cite>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comm</strong> (<em>MPI.Comm</em>) – MPI communicator to be used for
distributing the mesh.</p></li>
<li><p><strong>cpp_unf_domain</strong> (<a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_2D" title="qugar.cpp.UnfittedDomain_2D"><em>UnfittedDomain_2D</em></a><em> | </em><a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_3D" title="qugar.cpp.UnfittedDomain_3D"><em>UnfittedDomain_3D</em></a>) – C++ unfitted domain object.</p></li>
<li><p><strong>cpp_cart_grid_tp</strong> (<a class="reference internal" href="qugar.cpp.html#qugar.cpp.CartGridTP_2D" title="qugar.cpp.CartGridTP_2D"><em>CartGridTP_2D</em></a><em> | </em><a class="reference internal" href="qugar.cpp.html#qugar.cpp.CartGridTP_3D" title="qugar.cpp.CartGridTP_3D"><em>CartGridTP_3D</em></a>) – C++ Cartesian grid object.</p></li>
<li><p><strong>degree</strong> (<em>int</em><em>, </em><em>optional</em>) – Degree of the mesh. Defaults to 1.
It must be greater than zero.</p></li>
<li><p><strong>exclude_empty_cells</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, empty cells
are excluded from the mesh. Defaults to True.</p></li>
<li><p><strong>ghost_mode</strong> (<em>GhostMode</em><em>, </em><em>optional</em>) – Ghost mode used for mesh
partitioning. Defaults to <cite>none</cite>.</p></li>
<li><p><strong>dtype</strong> (<em>type</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em><em>, </em><em>optional</em>) – Type to
be used in the grid. Defaults to <cite>np.float64</cite>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain">
<em class="property"><span class="k"><span class="pre">class</span></span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">UnfittedDomain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mesh</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#qugar.mesh.Mesh" title="qugar.mesh.mesh.Mesh"><span class="pre">Mesh</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">cpp_unf_domain_object</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_2D" title="qugar.cpp.UnfittedDomain_2D"><span class="pre">UnfittedDomain_2D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_3D" title="qugar.cpp.UnfittedDomain_3D"><span class="pre">UnfittedDomain_3D</span></a></span></em><span class="sig-paren">)</span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">UnfittedDomainABC</span></code></p>
<p>Class for storing an unfitted domains
and access its cut, full, and empty cells and facets,
and create custom quadratures associated to those cells and facets.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This class is not intended to be used directly, but rather
as a class to be inherited by other classes, such as
<cite>UnfittedCartMesh</cite>.</p>
</div>
<p>Constructor.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mesh</strong> (<a class="reference internal" href="#qugar.mesh.Mesh" title="qugar.mesh.Mesh"><em>Mesh</em></a>) – Mesh object associated to the unfitted domain.</p></li>
<li><p><strong>cpp_unf_domain_object</strong> (<a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_2D" title="qugar.cpp.UnfittedDomain_2D"><em>UnfittedDomain_2D</em></a><em> | </em><a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_3D" title="qugar.cpp.UnfittedDomain_3D"><em>UnfittedDomain_3D</em></a>) – Already generated unfitted domain binary object.</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.cpp_unf_domain_object">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cpp_unf_domain_object</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_2D" title="qugar.cpp.UnfittedDomain_2D"><span class="pre">UnfittedDomain_2D</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_3D" title="qugar.cpp.UnfittedDomain_3D"><span class="pre">UnfittedDomain_3D</span></a></em><a class="headerlink" href="#qugar.mesh.UnfittedDomain.cpp_unf_domain_object" title="Link to this definition"></a></dt>
<dd><p>Gets the internal C++ unfitted domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Internal C++ unfitted domain.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_2D" title="qugar.cpp.UnfittedDomain_2D">UnfittedDomain_2D</a> | <a class="reference internal" href="qugar.cpp.html#qugar.cpp.UnfittedDomain_3D" title="qugar.cpp.UnfittedDomain_3D">UnfittedDomain_3D</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.create_quad_custom_cells">
<span class="sig-name descname"><span class="pre">create_quad_custom_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qugar.quad.html#qugar.quad.CustomQuad" title="qugar.quad.custom_quad.CustomQuad"><span class="pre">CustomQuad</span></a></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.create_quad_custom_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.create_quad_custom_cells" title="Link to this definition"></a></dt>
<dd><p>Returns the custom quadratures for the given <cite>cells</cite>.</p>
<p>For empty cells, no quadrature is generated and will have 0 points
associated to them. For full cells, the quadrature will be the
standard one associated to the cell type. While for
cut cells a custom quadrature for the cell’s interior will be
generated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This call requires the generation of the quadratures on
the fly, what can be potentially expensive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>degree</strong> (<em>int</em>) – Expected degree of exactness of the quadrature
to be generated.</p></li>
<li><p><strong>cells</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Array of DOLFINx cell ids
(local to current MPI process) for which quadratures
will be generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generated custom quadrature.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>CustomQuadInterface</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.create_quad_custom_facets">
<span class="sig-name descname"><span class="pre">create_quad_custom_facets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">facets</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">MeshFacets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ext_integral</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qugar.quad.html#qugar.quad.CustomQuadFacet" title="qugar.quad.custom_quad.CustomQuadFacet"><span class="pre">CustomQuadFacet</span></a></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.create_quad_custom_facets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.create_quad_custom_facets" title="Link to this definition"></a></dt>
<dd><p>Returns the custom quadratures for the given facets.</p>
<p>For empty facets, no quadrature is generated and will have 0 points
associated to them. For full facets, the quadrature will be the
standard one associated to the facet type. While for
cut facets a custom quadrature for the facet’s interior will be
generated.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This call requires the generation of the quadratures on
the fly, what can be potentially expensive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>degree</strong> (<em>int</em>) – Expected degree of exactness of the quadrature
to be generated.</p></li>
<li><p><strong>facets</strong> (<em>MeshFacets</em>) – MeshFacets object containing the
DOLFINx (local) facets for which quadratures will be
generated.</p></li>
<li><p><strong>ext_integral</strong> (<em>bool</em>) – Whether exterior integrals are
to be computed using the generated quadratures.
If <cite>True</cite>, the quadrature will be generated for the
facets that belong to the domain’s boundary (either
the mesh’s domain or the unfitted boundary).
Otherwise, the quadrature will be generated only for
the parts of the interior facets that are inside the
domain (but not its boundary).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generated custom facet
quadratures.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>CustomQuadFacetInterface</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.create_quad_unf_boundaries">
<span class="sig-name descname"><span class="pre">create_quad_unf_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cells</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="qugar.quad.html#qugar.quad.CustomQuadUnfBoundary" title="qugar.quad.custom_quad.CustomQuadUnfBoundary"><span class="pre">CustomQuadUnfBoundary</span></a></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.create_quad_unf_boundaries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.create_quad_unf_boundaries" title="Link to this definition"></a></dt>
<dd><p>Returns the custom quadrature for unfitted boundaries for the
given <cite>cells</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Some unfitted boundary parts may lay over facets.
The quadrature corresponding to those parts will not be
included in the quadrature generated by this function, but
in the one generated with the method
<cite>create_quad_custom_facets</cite>.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>For cells not containing unfitted boundaries, no quadrature
is generated and will have 0 points associated to them.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This call requires the generation of the quadratures on
the fly, what can be potentially expensive.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>degree</strong> (<em>int</em>) – Expected degree of exactness of the quadrature
to be generated.</p></li>
<li><p><strong>cells</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>]</em>) – Array of DOLFINx cell ids
(local to current MPI process) for which quadratures
will be generated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generated custom quadrature
for unfitted boundaries.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>CustomQuadUnfBoundaryInterface</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.get_cut_cells">
<span class="sig-name descname"><span class="pre">get_cut_cells</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.get_cut_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.get_cut_cells" title="Link to this definition"></a></dt>
<dd><p>Gets the ids of the cut cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Array of cut cells associated to the
current process following the DOLFINx local numbering.
The cell ids are sorted.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.get_cut_facets">
<span class="sig-name descname"><span class="pre">get_cut_facets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ext_integral</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">MeshFacets</span></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.get_cut_facets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.get_cut_facets" title="Link to this definition"></a></dt>
<dd><p>Gets the cut facets as a MeshFacets object following
the DOLFINx local numbering.</p>
<p>The list of facets will be filtered for exterior or interior
integrals according to the argument <cite>ext_integral</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The selection of facets is performed differently depending
on whether exterior or interior integrals are to be
computed.
For interior integrals we consider interior facets (shared
by two cells) that are cut (i.e., they are partially inside
the domain).
For exterior integrals we consider either interior or
exterior (that belong to a single cell) facets that
partially belong to the domain’s boundary (either the mesh’s
domain or the unfitted boundary).
In the case of exterior integrals, if a facet is fully
contained in an unfitted boundary, it is considered as full.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ext_integral</strong> (<em>bool</em>) – Whether the list of facets is
retrieved for computing exterior or interior integrals
(see note above).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Cut facets (following DOLFINx local ordering).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>MeshFacets</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.get_empty_cells">
<span class="sig-name descname"><span class="pre">get_empty_cells</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.get_empty_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.get_empty_cells" title="Link to this definition"></a></dt>
<dd><p>Gets the ids of the empty cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Array of empty cells associated to the
current process following the DOLFINx local numbering.
The cell ids are sorted.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.get_empty_facets">
<span class="sig-name descname"><span class="pre">get_empty_facets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ext_integral</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">MeshFacets</span></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.get_empty_facets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.get_empty_facets" title="Link to this definition"></a></dt>
<dd><p>Gets the empty facets as a MeshFacets object following
the DOLFINx local numbering.</p>
<p>The list of facets will be filtered to only exterior or interior
facets according to the argument <cite>exterior</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The selection of facets is performed differently depending
on whether exterior or interior integrals are to be
computed.
For interior integrals we consider interior facets (shared
by two cells) that are not contained in the domain (they
may be contained (fully or partially) in the unfitted
boundary).
For exterior integrals we consider exterior facets (that
belong to a single cell) that are not contained in the
domain or its boundary.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ext_integral</strong> (<em>bool</em>) – Whether the list of facets is
retrieved for computing exterior or interior integrals
(see note above).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Empty facets (following DOLFINx local ordering).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>MeshFacets</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.get_full_cells">
<span class="sig-name descname"><span class="pre">get_full_cells</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.get_full_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.get_full_cells" title="Link to this definition"></a></dt>
<dd><p>Gets the ids of the full cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Array of full cells associated to the
current process following the DOLFINx local numbering.
The cell ids are sorted.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.get_full_facets">
<span class="sig-name descname"><span class="pre">get_full_facets</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ext_integral</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">MeshFacets</span></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.get_full_facets"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.get_full_facets" title="Link to this definition"></a></dt>
<dd><p>Gets the full facets as a MeshFacets object following
the DOLFINx local numbering.</p>
<p>The list of facets will be filtered for exterior or interior
integrals according to the argument <cite>ext_integral</cite>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The selection of facets is performed differently depending
on whether exterior or interior integrals are to be
computed.
For interior integrals we consider interior facets (shared
by two cells) that are fully inside the domain (and not
contained in any unfitted boundary).
For exterior integrals we consider facets (interior or
exterior) that are fully contained in the domain’s boundary
(either the mesh’s domain or the unfitted boundary).</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ext_integral</strong> (<em>bool</em>) – Whether the list of facets is
retrieved for computing exterior or interior integrals
(see note above).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Full facets (following DOLFINx local ordering).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>MeshFacets</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.get_num_Gauss_points">
<em class="property"><span class="k"><span class="pre">static</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_num_Gauss_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_domain.html#UnfittedDomain.get_num_Gauss_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.UnfittedDomain.get_num_Gauss_points" title="Link to this definition"></a></dt>
<dd><p>Returns the number of points per direction to be used
for a given degree of exactness.</p>
<p>It computes the number of points assuming the Gauss-Legendre quadrature.
The degree of exactness is 2 times the number of points minus one.</p>
<p>It does not consider the map of of the quadrature tile.
A slightly higher number of points/degree may be needed.
See the Appendix of the following paper for more details:</p>
<dl class="simple">
<dt>Antolin, P., Wei, X. and Buffa, A., 2022. Robust numerical integration on curved</dt><dd><p>polyhedra based on folded decompositions.
Computer Methods in Applied Mechanics and Engineering, 395, p.114948.</p>
</dd>
</dl>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>degree</strong> (<em>int</em>) – Expected degree of exactness of the quadrature.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Number of quadrature points per direction for every quadrature tile.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="qugar.mesh.UnfittedDomain.mesh">
<em class="property"><span class="k"><span class="pre">property</span></span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mesh</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="#qugar.mesh.Mesh" title="qugar.mesh.mesh.Mesh"><span class="pre">Mesh</span></a></em><a class="headerlink" href="#qugar.mesh.UnfittedDomain.mesh" title="Link to this definition"></a></dt>
<dd><p>Gets the mesh object associated to the unfitted domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Mesh object associated to the unfitted domain.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="#qugar.mesh.Mesh" title="qugar.mesh.Mesh">Mesh</a></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.VTK_to_DOLFINx_nodes">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">VTK_to_DOLFINx_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#VTK_to_DOLFINx_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.VTK_to_DOLFINx_nodes" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from VTK to DOLFINx nodes
ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – Cell’s degree. It must be greater than 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from VTK to DOLFINx</dt><dd><p>such that <cite>a_vtk[i] = a_dlf[perm_array[i]]</cite> or
<cite>a_dlf[i] = perm_array[a_vtk[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The VTK numbering is referred to the Arbitrary-order Lagrange
Finite Elements as defined in
<a class="reference external" href="https://www.kitware.com//modeling-arbitrary-order-lagrange-finite-elements-in-the-visualization-toolkit">https://www.kitware.com//modeling-arbitrary-order-lagrange-finite-elements-in-the-visualization-toolkit</a>
These are the cells with cell ids 68 (1D), 70 (2D), or 72 (3D),
and not the linear ones (3, 9, 12, respec.) or quadratic (21,
28, 29, respec.).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.VTK_to_lexicg_faces">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">VTK_to_lexicg_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#VTK_to_lexicg_faces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.VTK_to_lexicg_faces" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from VTK to
lexicographical faces ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from VTK to</dt><dd><p>lexicographical such that <cite>faces_lex[i] = faces_vtk[perm_array[i]]</cite> or
<cite>faces_vtk[i] = perm_array[faces_lex[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.VTK_to_lexicg_nodes">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">VTK_to_lexicg_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#VTK_to_lexicg_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.VTK_to_lexicg_nodes" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from VTK to lexicographical
nodes ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – Cell’s degree. It must be greater than 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from VTK to</dt><dd><p>lexicographical such that <cite>a_vtk[i] = a_lex[perm_array[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The VTK numbering is referred to the Arbitrary-order Lagrange
Finite Elements as defined in
<a class="reference external" href="https://www.kitware.com//modeling-arbitrary-order-lagrange-finite-elements-in-the-visualization-toolkit">https://www.kitware.com//modeling-arbitrary-order-lagrange-finite-elements-in-the-visualization-toolkit</a>
These are the cells with cell ids 68 (1D), 70 (2D), or 72 (3D),
and not the linear ones (3, 9, 12, respec.) or quadratic (21,
28, 29, respec.).</p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.create_Cartesian_mesh">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">create_Cartesian_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_cells</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ghost_mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GhostMode</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">GhostMode.none</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qugar.mesh.CartesianMesh" title="qugar.mesh.tp_mesh.CartesianMesh"><span class="pre">CartesianMesh</span></a></span></span><a class="reference internal" href="../_modules/qugar/mesh/tp_mesh.html#create_Cartesian_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.create_Cartesian_mesh" title="Link to this definition"></a></dt>
<dd><p>Creates a Cartesian mesh from a bounding box and the number of
cells per direction.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comm</strong> – MPI communicator to be used for distributing the mesh.</p></li>
<li><p><strong>n_cells</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>] </em><em>| </em><em>list</em><em>[</em><em>np.int32</em><em>] </em><em>| </em><em>list</em><em>[</em><em>int</em><em>]</em>) – Number of cells per direction in the mesh.</p></li>
<li><p><strong>xmin</strong> (<em>Optional</em><em>[</em><em>npt.NDArray</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em><em>]</em>) – Minimum
coordinates of the mesh’s bounding box. Defaults to a vector
of zeros with double floating precision.</p></li>
<li><p><strong>xmax</strong> (<em>Optional</em><em>[</em><em>npt.NDArray</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em><em>]</em>) – Maximum
coordinates of the mesh’s bounding box. Defaults to a vector
of ones with double floating precision.</p></li>
<li><p><strong>degree</strong> (<em>int</em><em>, </em><em>optional</em>) – Degree of the mesh. Defaults to 1.</p></li>
<li><p><strong>ghost_mode</strong> (<em>GhostMode</em><em>, </em><em>optional</em>) – Ghost mode used for mesh
partitioning. Defaults to <cite>none</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generated Cartesian mesh.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#qugar.mesh.CartesianMesh" title="qugar.mesh.CartesianMesh">CartesianMesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.create_unfitted_impl_Cartesian_mesh">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">create_unfitted_impl_Cartesian_mesh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">comm</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Comm</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">impl_func</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="qugar.impl.html#qugar.impl.ImplicitFunc" title="qugar.impl.impl_function.ImplicitFunc"><span class="pre">ImplicitFunc</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_cells</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">list</span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmin</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xmax</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_empty_cells</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ghost_mode</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">GhostMode</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">GhostMode.none</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">type</span><span class="p"><span class="pre">[</span></span><span class="pre">float32</span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">float64</span><span class="p"><span class="pre">]</span></span><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><span class="pre">None</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#qugar.mesh.UnfittedCartMesh" title="qugar.mesh.unfitted_cart_mesh.UnfittedCartMesh"><span class="pre">UnfittedCartMesh</span></a></span></span><a class="reference internal" href="../_modules/qugar/mesh/unfitted_cart_mesh.html#create_unfitted_impl_Cartesian_mesh"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.create_unfitted_impl_Cartesian_mesh" title="Link to this definition"></a></dt>
<dd><p>Creates an uniftted Cartesian mesh generated with a bounding box and the number of
cells per direction, and an implicit function describing the domain</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>comm</strong> – MPI communicator to be used for distributing the mesh.</p></li>
<li><p><strong>impl_func</strong> (<a class="reference internal" href="qugar.cpp.html#qugar.cpp.ImplicitFunc_2D" title="qugar.cpp.ImplicitFunc_2D"><em>ImplicitFunc_2D</em></a><em> | </em><a class="reference internal" href="qugar.cpp.html#qugar.cpp.ImplicitFunc_3D" title="qugar.cpp.ImplicitFunc_3D"><em>ImplicitFunc_3D</em></a>) – Implicit function
that describes the domain.</p></li>
<li><p><strong>n_cells</strong> (<em>npt.NDArray</em><em>[</em><em>np.int32</em><em>] </em><em>| </em><em>list</em><em>[</em><em>np.int32</em><em>] </em><em>| </em><em>list</em><em>[</em><em>int</em><em>] </em><em>| </em><em>int</em>) – Number of cells per direction in the mesh.</p></li>
<li><p><strong>xmin</strong> (<em>Optional</em><em>[</em><em>npt.NDArray</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em><em>]</em>) – Minimum
coordinates of the mesh’s bounding box. Defaults to a vector
of zeros with double floating precision.</p></li>
<li><p><strong>xmax</strong> (<em>Optional</em><em>[</em><em>npt.NDArray</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em><em>]</em>) – Maximum
coordinates of the mesh’s bounding box. Defaults to a vector
of ones with double floating precision.</p></li>
<li><p><strong>degree</strong> (<em>int</em><em>, </em><em>optional</em>) – Degree of the mesh. Defaults to 1.</p></li>
<li><p><strong>exclude_empty_cells</strong> (<em>bool</em><em>, </em><em>optional</em>) – If True, empty cells
are excluded from the mesh. Defaults to True.</p></li>
<li><p><strong>ghost_mode</strong> (<em>GhostMode</em><em>, </em><em>optional</em>) – Ghost mode used for mesh
partitioning. Defaults to <cite>none</cite>.</p></li>
<li><p><strong>dtype</strong> (<em>Optional</em><em>[</em><em>type</em><em>[</em><em>np.float32</em><em> | </em><em>np.float64</em><em>]</em><em>]</em>) – Type to
be used in the grid. If not provided, it will be inferred
from <cite>xmin</cite> and/or <cite>xmax</cite>, and if not provided either
it will be set to <cite>np.float64</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Generated unfitted Cartesian mesh.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="#qugar.mesh.UnfittedCartMesh" title="qugar.mesh.UnfittedCartMesh">UnfittedCartMesh</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.lexicg_to_DOLFINx_edges">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">lexicg_to_DOLFINx_edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#lexicg_to_DOLFINx_edges"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.lexicg_to_DOLFINx_edges" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from lexicographical to
DOLFINx edges ordering.</p>
<p>See <a class="reference external" href="https://github.com/FEniCS/basix/#supported-elements">https://github.com/FEniCS/basix/#supported-elements</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from lexicographical</dt><dd><p>to DOLFINx such that <cite>edges_dlf[i] = edges_lex[perm_array[i]]</cite>
or <cite>edges_lex[i] = perm_array[edges_dlf[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.lexicg_to_DOLFINx_faces">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">lexicg_to_DOLFINx_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#lexicg_to_DOLFINx_faces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.lexicg_to_DOLFINx_faces" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from lexicographical to
DOLFINx faces ordering.</p>
<p>See <a class="reference external" href="https://github.com/FEniCS/basix/#supported-elements">https://github.com/FEniCS/basix/#supported-elements</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from lexicographical</dt><dd><p>to DOLFINx such that <cite>faces_dlf[i] = faces_lex[perm_array[i]]</cite>
or <cite>faces_lex[i] = perm_array[faces_dlf[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.lexicg_to_DOLFINx_nodes">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">lexicg_to_DOLFINx_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#lexicg_to_DOLFINx_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.lexicg_to_DOLFINx_nodes" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from lexicographical to
DOLFINx nodes ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – Cell’s degree. It must be greater than 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from lexicographical to</dt><dd><p>DOLFINx, i.e., such that <cite>a_lex[i] = a_dlf[perm_array[i]]</cite> or
<cite>a_dlf[i] = perm_array[a_lex[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.lexicg_to_VTK_faces">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">lexicg_to_VTK_faces</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#lexicg_to_VTK_faces"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.lexicg_to_VTK_faces" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from lexicographical to
VTK faces ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from lexicographical</dt><dd><p>to VTK such that <cite>faces_vtk[i] = faces_lex[perm_array[i]]</cite>
or <cite>faces_lex[i] = perm_array[faces_vtk[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="qugar.mesh.lexicg_to_VTK_nodes">
<span class="sig-prename descclassname"><span class="pre">qugar.mesh.</span></span><span class="sig-name descname"><span class="pre">lexicg_to_VTK_nodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">Any</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">dtype</span><span class="p"><span class="pre">[</span></span><span class="pre">int32</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../_modules/qugar/mesh/utils.html#lexicg_to_VTK_nodes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#qugar.mesh.lexicg_to_VTK_nodes" title="Link to this definition"></a></dt>
<dd><p>Creates the permutation array to map from lexicographical to VTK
nodes ordering.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<em>int</em>) – Parametric dimension of the cells (1D, 2D, or 3D).</p></li>
<li><p><strong>degree</strong> (<em>int</em>) – Cell’s degree. It must be greater than 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><dl class="simple">
<dt>Permutation array from lexicographical to</dt><dd><p>VTK such that <cite>a_lex[i] = a_vtk[perm_array[i]]</cite> or
<cite>a_vtk[i] = perm_array[a_lex[i]]</cite>.</p>
</dd>
</dl>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>npt.NDArray[np.int32]</p>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The VTK numbering is referred to the Arbitrary-order Lagrange
Finite Elements as defined in
<a class="reference external" href="https://www.kitware.com//modeling-arbitrary-order-lagrange-finite-elements-in-the-visualization-toolkit">https://www.kitware.com//modeling-arbitrary-order-lagrange-finite-elements-in-the-visualization-toolkit</a>
These are the cells with cell ids 68 (1D), 70 (2D), or 72 (3D),
and not the linear ones (3, 9, 12, respec.) or quadratic (21,
28, 29, respec.).</p>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="qugar.html" class="btn btn-neutral float-left" title="qugar" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="qugar.impl.html" class="btn btn-neutral float-right" title="qugar.impl" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Pablo Antolin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>